{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Harneet Programming Language - Beginner's Guide","text":"<p>Welcome to Harneet! This guide will teach you everything you need to know about the Harneet programming language, designed especially for newcomers to programming. Inspired by golang and some python! </p>"},{"location":"#what-is-harneet","title":"\ud83c\udf1f What is Harneet?","text":"<p>Harneet is a simple, easy-to-learn programming language that's perfect for beginners. It has clean syntax inspired by Go and includes basic programming concepts like variables, math, and decision-making.</p> <p>Think of Harneet as a friendly way to learn programming fundamentals before moving on to more complex languages.</p> <p>Please see the Language Specification, for detailed language specifications.</p> <p>Please note that Harneet is still being actively worked on and features that you would normally see in other programming languages are still not present in Harneet.Definitely not to be used in Production!!</p>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"#installation-running-programs","title":"Installation &amp; Running Programs","text":"<ol> <li> <p>Build Harneet (one-time setup):    <code>bash    just build    # This creates the 'harneet' program</code></p> </li> <li> <p>Try the interactive mode (REPL):    <code>bash    just repl    # Type commands and see results immediately</code></p> </li> <li> <p>Run a program file:    <code>bash    ./harneet examples/hello.ha    # Runs code from a file (uses .ha extension)</code></p> </li> </ol>"},{"location":"#your-first-program","title":"\ud83d\udcdd Your First Program","text":"<p>Let's start with the classic \"Hello, World!\" program:</p> <pre><code>import fmt\nfmt.Println(\"Hello, World!\")\n</code></pre> <p>What this does: - <code>import fmt</code> loads the formatting module (needed for printing) - <code>fmt.Println()</code> is a command that prints text to the screen - The text inside quotes <code>\"Hello, World!\"</code> is what gets printed - Every statement in Harneet can be on its own line</p> <p>Try it yourself: 1. Save this code in a file called <code>hello.ha</code> 2. Run it with: <code>./harneet hello.ha</code></p>"},{"location":"#working-with-numbers","title":"\ud83d\udd22 Working with Numbers","text":"<p>Harneet can do math! Here are the basics:</p> <pre><code>import fmt\nfmt.Println(5 + 3)    // Prints: 8\nfmt.Println(10 - 4)   // Prints: 6  \nfmt.Println(6 * 7)    // Prints: 42\nfmt.Println(15 / 3)   // Prints: 5\nfmt.Println(17 % 5)   // Prints: 2 (remainder)\n</code></pre> <p>Math Operators: - <code>+</code> addition - <code>-</code> subtraction - <code>*</code> multiplication - <code>/</code> division - <code>%</code> remainder (modulo)</p>"},{"location":"#variables-storing-information","title":"\ud83d\udce6 Variables - Storing Information","text":"<p>Variables are like labeled boxes where you can store information. Harneet supports two ways to create variables:</p> <p>Method 1: Explicit Types (tell Harneet the type):</p> <pre><code>var age int = 25\nvar name string = \"Alice\"\n</code></pre> <p>Method 2: Type Inference (let Harneet figure out the type):</p> <pre><code>var age = 25        // Harneet knows this is an int\nvar name = \"Alice\"  // Harneet knows this is a string\n</code></pre> <p>Both work exactly the same! Choose whichever feels more comfortable.</p> <pre><code>fmt.Println(\"Name:\", name)\nfmt.Println(\"Age:\", age)\n</code></pre> <p>How variables work: - <code>var</code> tells Harneet you're creating a variable - <code>age</code> is the variable name (you choose this) - <code>int</code> or automatic type detection means it stores whole numbers - <code>= 25</code> puts the value 25 into the variable</p> <p>Variable Types: - <code>int</code> - whole numbers (1, 42, -5) - <code>string</code> - text in quotes (\"hello\", \"Harneet\")</p>"},{"location":"#changing-variables","title":"Changing Variables","text":"<p>You can change what's stored in a variable:</p> <pre><code>var score int = 100\nfmt.Println(\"Score:\", score)  // Prints: Score: 100\n\nscore = 150\nfmt.Println(\"New score:\", score)  // Prints: New score: 150\n</code></pre>"},{"location":"#quick-variable-creation","title":"Quick Variable Creation","text":"<p>There's a shortcut for creating variables:</p> <pre><code>x := 42        // Same as: var x int = 42\nmessage := \"Hi there\"  // Same as: var message string = \"Hi there\"\n</code></pre>"},{"location":"#math-with-variables","title":"\ud83e\uddee Math with Variables","text":"<p>You can do math with variables just like with numbers:</p> <pre><code>var a int = 10\nvar b int = 5\n\nfmt.Println(\"a + b =\", a + b)    // Prints: a + b = 15\nfmt.Println(\"a * b =\", a * b)    // Prints: a * b = 50\n\nvar total int = a + b + 20\nfmt.Println(\"Total:\", total)     // Prints: Total: 35\n</code></pre>"},{"location":"#making-decisions-with-if","title":"\ud83e\udd14 Making Decisions with <code>if</code>","text":"<p>Sometimes your program needs to make decisions based on conditions:</p> <pre><code>var temperature int = 75\n\nif temperature &gt; 70 {\n    fmt.Println(\"It's warm outside!\")\n}\n</code></pre> <p>How <code>if</code> works: - <code>if</code> starts the decision - <code>temperature &gt; 70</code> is the condition (true or false) - Code inside <code>{ }</code> runs only if the condition is true</p>"},{"location":"#comparison-operators","title":"Comparison Operators","text":"<p>These help you compare values:</p> <pre><code>var x int = 10\nvar y int = 20\n\nif x &lt; y {\n    fmt.Println(\"x is smaller than y\")\n}\n\nif x == 10 {\n    fmt.Println(\"x equals 10\")\n}\n\nif y != 15 {\n    fmt.Println(\"y is not 15\")\n}\n</code></pre> <p>Comparison operators: - <code>&lt;</code> less than - <code>&gt;</code> greater than - <code>&lt;=</code> less than or equal - <code>&gt;=</code> greater than or equal - <code>==</code> equals - <code>!=</code> not equals</p>"},{"location":"#repeating-with-loops","title":"\ud83d\udd04 Repeating with Loops","text":"<p>Loops let you repeat code multiple times:</p> <pre><code>for i := 0; i &lt; 5; i = i + 1 {\n    fmt.Println(\"Count:\", i)\n}\n</code></pre> <p>This prints:</p> <pre><code>Count: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4\n</code></pre> <p>How the loop works: - <code>i := 0</code> creates a counter starting at 0 - <code>i &lt; 5</code> continues while i is less than 5 - <code>i = i + 1</code> adds 1 to i after each round - Code in <code>{ }</code> runs each time</p>"},{"location":"#simple-loops","title":"Simple Loops","text":"<p>You can also make simpler loops:</p> <pre><code>var count int = 0\nfor count &lt; 3 {\n    fmt.Println(\"Hello!\")\n    count = count + 1\n}\n</code></pre>"},{"location":"#logical-operators","title":"\ud83d\udd17 Logical Operators","text":"<p>You can combine conditions using logical operators:</p> <pre><code>var age int = 20\nvar hasLicense int = 1  // 1 means true, 0 means false\n\nif age &gt;= 16 and hasLicense == 1 {\n    fmt.Println(\"Can drive!\")\n}\n\nvar isWeekend int = 1\nvar isHoliday int = 0\n\nif isWeekend == 1 or isHoliday == 1 {\n    fmt.Println(\"No work today!\")\n}\n</code></pre> <p>Logical operators: - <code>and</code> - both conditions must be true - <code>or</code> - at least one condition must be true - <code>not</code> - flips true to false, false to true</p>"},{"location":"#complete-example-programs","title":"\ud83d\udccb Complete Example Programs","text":""},{"location":"#example-1-age-calculator","title":"Example 1: Age Calculator","text":"<pre><code>var birthYear int = 2000\nvar currentYear int = 2024\nvar age int = currentYear - birthYear\n\nfmt.Println(\"Birth year:\", birthYear)\nfmt.Println(\"Current year:\", currentYear)\nfmt.Println(\"Your age is:\", age)\n\nif age &gt;= 18 {\n    fmt.Println(\"You are an adult!\")\n}\n</code></pre>"},{"location":"#example-2-simple-calculator","title":"Example 2: Simple Calculator","text":"<pre><code>var num1 int = 15\nvar num2 int = 4\n\nfmt.Println(\"Number 1:\", num1)\nfmt.Println(\"Number 2:\", num2)\nfmt.Println(\"Sum:\", num1 + num2)\nfmt.Println(\"Difference:\", num1 - num2)\nfmt.Println(\"Product:\", num1 * num2)\nfmt.Println(\"Division:\", num1 / num2)\nfmt.Println(\"Remainder:\", num1 % num2)\n</code></pre>"},{"location":"#example-3-grade-checker","title":"Example 3: Grade Checker","text":"<pre><code>var score int = 85\n\nfmt.Println(\"Your score:\", score)\n\nif score &gt;= 90 {\n    fmt.Println(\"Grade: A - Excellent!\")\n}\n\nif score &gt;= 80 and score &lt; 90 {\n    fmt.Println(\"Grade: B - Good job!\")\n}\n\nif score &gt;= 70 and score &lt; 80 {\n    fmt.Println(\"Grade: C - Not bad!\")\n}\n\nif score &lt; 70 {\n    fmt.Println(\"Grade: F - Study more!\")\n}\n</code></pre>"},{"location":"#built-in-modules-advanced-features","title":"\ud83d\udcda Built-in Modules (Advanced Features)","text":"<p>As you get more comfortable with Harneet, you can explore its built-in modules for more powerful features:</p> <pre><code>import fmt      // Printing and formatting\nimport math     // Mathematical functions\nimport strings  // Text manipulation\nimport datetime // Date and time operations\nimport os       // Operating system features\nimport file     // File operations\nimport log      // Logging messages\nimport assert   // Runtime assertions for testing and debugging\n</code></pre> <p>These modules provide advanced functionality when you're ready to explore them!</p>"},{"location":"#things-harneet-doesnt-have-yet","title":"\ud83d\udeab Things Harneet Doesn't Have (Yet)","text":"<p>Harneet is designed for learning, so it doesn't have some advanced features: (we are still working on them) - Complex data types</p> <p>This focused approach makes it perfect for learning programming fundamentals!</p>"},{"location":"#tips-for-success","title":"\ud83d\udd27 Tips for Success","text":"<ol> <li>Start small - Begin with simple programs and add complexity gradually</li> <li>Experiment - Try changing values and see what happens</li> <li>Use the REPL - Test small pieces of code interactively</li> <li>Read error messages - They tell you what went wrong</li> <li>Practice daily - Even 10 minutes a day helps!</li> </ol>"},{"location":"#common-beginner-mistakes","title":"\ud83d\udc1b Common Beginner Mistakes","text":""},{"location":"#mistake-1-missing-quotes-for-text","title":"Mistake 1: Missing quotes for text","text":"<pre><code>// Wrong:\nfmt.Println(Hello)\n\n// Right:\nfmt.Println(\"Hello\")\n</code></pre>"},{"location":"#mistake-2-using-instead-of","title":"Mistake 2: Using = instead of ==","text":"<pre><code>// Wrong (assigns value):\nif x = 5 {\n\n// Right (compares):\nif x == 5 {\n</code></pre>"},{"location":"#mistake-3-trying-to-use-a-single-variable-for-functions-that-return-multiple-values","title":"Mistake 3: Trying to use a single variable for functions that return multiple values","text":"<pre><code>// Wrong (shows helpful error message):\nvar result = math.Abs(-42)\n\n// Right (handle both result and error):\nvar result, err = math.Abs(-42)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result)\n}\n</code></pre>"},{"location":"#next-steps","title":"\ud83c\udfaf Next Steps","text":"<p>Once you're comfortable with Harneet, you might want to learn: 1. Go - Harneet's syntax is similar to Go 2. Python - Great for beginners, very popular 3. JavaScript - For web development 4. C - To understand how computers work</p>"},{"location":"#getting-help","title":"\ud83d\udd17 Getting Help","text":"<ul> <li>Run examples: <code>just test</code> runs all example programs</li> <li>Try interactive mode: <code>just repl</code> for experimenting</li> <li>Check the documentation: Read <code>CLAUDE.md</code> for technical details</li> <li>Practice: The <code>examples/</code> folder has more programs to study</li> </ul>"},{"location":"#automatic-releases","title":"\ud83c\udff7\ufe0f Automatic Releases","text":"<p>The project uses conventional commit messages to automatically create releases:</p> <ul> <li><code>feat:</code> \u2192 Creates a minor version bump (e.g., 1.0.0 \u2192 1.1.0)</li> <li><code>fix:</code> \u2192 Creates a patch version bump (e.g., 1.0.0 \u2192 1.0.1)  </li> <li><code>BREAKING CHANGE:</code> \u2192 Creates a major version bump (e.g., 1.0.0 \u2192 2.0.0)</li> </ul> <p>Example commit messages:</p> <pre><code>git commit -m \"feat: add new string manipulation functions\"\ngit commit -m \"fix: resolve parser error with semicolons\"\ngit commit -m \"feat!: redesign error handling system\n\nBREAKING CHANGE: all functions now return (result, error) tuples\"\n</code></pre> <p>When you push commits with these prefixes to the main branch, GitHub Actions will automatically: - Determine the next version number - Create a git tag - Build release binaries for multiple platforms - Create a GitHub release with download links</p>"},{"location":"#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You now know the basics of the Harneet programming language! Remember: - Programming is like learning a new language - it takes practice - Every expert was once a beginner - The most important thing is to keep experimenting and having fun!</p> <p>Happy coding! \ud83d\ude80</p>"},{"location":"comprehensive_examples/","title":"Comprehensive Language Examples","text":"<p>This page provides a collection of examples that demonstrate various features of the Harneet programming language.</p>"},{"location":"comprehensive_examples/#array-operations","title":"Array Operations","text":"<pre><code>import fmt, arrays\n\nvar nums = [1, 2, 3, 4, 5]\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\nvar mixed = [1, \"hello\", 3.14, true]\n\n// Array operations\nvar length, _ = arrays.length(nums)\nvar contains, _ = arrays.contains(names, \"Alice\")\nvar newArray, _ = arrays.push(nums, 6)\nvar sortedNums, _ = arrays.sort([3, 1, 4, 1, 5])\n\nfmt.Println(\"Length:\", length)\nfmt.Println(\"Contains Alice:\", contains)\nfmt.Println(\"New array:\", newArray)\nfmt.Println(\"Sorted:\", sortedNums)\n</code></pre>"},{"location":"comprehensive_examples/#json-processing","title":"JSON Processing","text":"<pre><code>import json, fmt\n\nvar data = [\"apple\", \"banana\", \"cherry\"]\nvar jsonString, err = json.Marshal(data)\nif err != None {\n    fmt.Println(\"Marshal error:\", err)\n    return\n}\n\nfmt.Println(\"JSON:\", jsonString)\n\nvar parsed, parseErr = json.Unmarshal(jsonString)\nif parseErr != None {\n    fmt.Println(\"Parse error:\", parseErr)\n    return\n}\n\nfmt.Println(\"Parsed back:\", parsed)\n</code></pre>"},{"location":"comprehensive_examples/#file-operations","title":"File Operations","text":"<pre><code>import file, fmt\n\nvar content = \"Hello, World!\\nThis is Harneet!\"\nvar writeErr = file.Write(\"example.txt\", content)\nif writeErr != None {\n    fmt.Println(\"Write error:\", writeErr)\n    return\n}\n\nvar readContent, readErr = file.Read(\"example.txt\")\nif readErr != None {\n    fmt.Println(\"Read error:\", readErr)\n    return\n}\n\nfmt.Println(\"File content:\", readContent)\n</code></pre>"},{"location":"comprehensive_examples/#advanced-function-usage","title":"Advanced Function Usage","text":"<pre><code>import fmt\n\n// Regular function with multiple returns\nfunction processData(data string) (string, string, bool) {\n    if data == \"\" {\n        return \"\", \"empty data\", false\n    }\n    return data.Upper(), \"\", true\n}\n\n// Arrow function for simple operations\nvar multiply = (a, b) =&gt; a * b\nvar greet = name =&gt; \"Hello, \" + name\n\n// Using functions\nvar result, error, success = processData(\"hello world\")\nif success {\n    fmt.Println(\"Result:\", result)\n} else {\n    fmt.Println(\"Error:\", error)\n}\n\nfmt.Println(\"Product:\", multiply(6, 7))\nfmt.Println(\"Greeting:\", greet(\"Alice\"))\n</code></pre>"},{"location":"comprehensive_examples/#file-io-examples","title":"File I/O Examples","text":"<p>This section provides comprehensive examples of file input/output operations.</p>"},{"location":"comprehensive_examples/#reading-writing-and-appending-files","title":"Reading, Writing, and Appending Files","text":"<pre><code>import fmt\nimport file\nimport os\n\n// Create a new file and write content to it\nvar fileName = \"test_file.txt\"\nvar initialContent = \"Hello from Harneet!\"\nvar writeErr = file.Write(fileName, initialContent)\nif writeErr != None {\n    fmt.Println(\"Error writing to file:\", writeErr)\n    return\n}\nfmt.Println(\"Successfully wrote to\", fileName)\n\n// Read the content of the file\nvar content, readErr = file.Read(fileName)\nif readErr != None {\n    fmt.Println(\"Error reading file:\", readErr)\n    return\n}\nfmt.Println(\"Content of\", fileName, \":\", content)\n\n// Append content to the file\nvar appendedContent = \"\\nThis is a new line.\"\nvar appendErr = file.Append(fileName, appendedContent)\nif appendErr != None {\n    fmt.Println(\"Error appending to file:\", appendErr)\n    return\n}\nfmt.Println(\"Successfully appended to\", fileName)\n\n// Read the file again to see the appended content\nvar newContent, readAgainErr = file.Read(fileName)\nif readAgainErr != None {\n    fmt.Println(\"Error reading file again:\", readAgainErr)\n    return\n}\nfmt.Println(\"New content of\", fileName, \":\", newContent)\n\n// Clean up the created file\nos.Remove(fileName)\n</code></pre>"},{"location":"comprehensive_examples/#datetime-examples","title":"Datetime Examples","text":"<p>This section provides comprehensive examples of date and time operations.</p>"},{"location":"comprehensive_examples/#timezone-conversions-and-formatting","title":"Timezone Conversions and Formatting","text":"<pre><code>import fmt\nimport datetime\n\n// Get the current time in UTC\nvar nowUTC, _ = datetime.Now()\nfmt.Println(\"Current UTC time (Unix):\", nowUTC)\n\n// Format the UTC time\nvar formattedUTC, _ = datetime.Format(nowUTC, \"RFC3339\")\nfmt.Println(\"Formatted UTC time:\", formattedUTC)\n\n// Convert to a different timezone\nvar newYorkTime, _ = datetime.ConvertTZ(nowUTC, \"UTC\", \"America/New_York\")\nvar formattedNY, _ = datetime.Format(newYorkTime, \"Kitchen\")\nfmt.Println(\"New York time:\", formattedNY)\n\n// Get the system's timezone\nvar systemTZ, _ = datetime.GetSystemTZ()\nfmt.Println(\"System timezone:\", systemTZ)\n</code></pre>"},{"location":"comprehensive_examples/#cron-job-scheduling","title":"Cron Job Scheduling","text":"<pre><code>import fmt\nimport datetime\nimport time\n\n// Schedule a cron job to run every 2 seconds\nvar cronID = \"my_cron_job\"\nvar cronExpr = \"*/2 * * * * *\" // Every 2 seconds\nvar scheduleErr, _ = datetime.ScheduleCron(cronID, cronExpr)\nif scheduleErr != None {\n    fmt.Println(\"Error scheduling cron job:\", scheduleErr)\n    return\n}\nfmt.Println(\"Scheduled cron job with ID:\", cronID)\n\n// Let the cron job run for a few seconds\nfmt.Println(\"Waiting for cron job to run...\")\ntime.Sleep(5)\n\n// Stop the cron job\nvar stopErr, _ = datetime.StopCron(cronID)\nif stopErr != None {\n    fmt.Println(\"Error stopping cron job:\", stopErr)\n} else {\n    fmt.Println(\"Stopped cron job with ID:\", cronID)\n}\n</code></pre>"},{"location":"comprehensive_examples/#logging-examples","title":"Logging Examples","text":"<p>This section provides comprehensive examples of logging.</p>"},{"location":"comprehensive_examples/#logging-at-different-levels","title":"Logging at Different Levels","text":"<pre><code>import log\n\nlog.Debug(\"This is a debug message.\")\nlog.Info(\"This is an info message.\")\nlog.Warn(\"This is a warning message.\")\nlog.Error(\"This is an error message.\")\n</code></pre>"},{"location":"comprehensive_examples/#setting-log-level","title":"Setting Log Level","text":"<pre><code>import log\n\n// Set the log level to WARN\nlog.SetLevel(\"WARN\")\n\nlog.Debug(\"This message will not be printed.\")\nlog.Info(\"This message will also not be printed.\")\nlog.Warn(\"This is a warning message that will be printed.\")\nlog.Error(\"This is an error message that will also be printed.\")\n\n// Reset log level to default (DEBUG)\nlog.SetLevel(\"DEBUG\")\n</code></pre>"},{"location":"comprehensive_examples/#redirecting-log-output-to-a-file","title":"Redirecting Log Output to a File","text":"<pre><code>import log\nimport file\nimport os\n\nvar logFile = \"app.log\"\n\n// Redirect log output to a file\nlog.SetOutput(logFile)\n\nlog.Info(\"This message will be written to the log file.\")\n\n// Reset log output to standard output\nlog.SetOutput(\"\")\n\n// Read the log file to verify the content\nvar logContent, _ = file.Read(logFile)\nfmt.Println(\"Log file content:\", logContent)\n\n// Clean up the log file\nos.Remove(logFile)\n</code></pre>"},{"location":"comprehensive_examples/#os-module-examples","title":"OS Module Examples","text":"<p>This section provides comprehensive examples of interacting with the operating system.</p>"},{"location":"comprehensive_examples/#device-information-and-drive-information","title":"Device Information and Drive Information","text":"<pre><code>import fmt\nimport os\n\n// List all connected devices\nvar devices, err = os.ListDevices()\nif err != None {\n    fmt.Println(\"Error listing devices:\", err)\n} else {\n    fmt.Println(\"Connected Devices:\", devices)\n}\n\n// Get detailed information about a specific device (example: first device in the list)\nif devices != None &amp;&amp; arrays.length(devices) &gt; 0 {\n    var firstDevice = devices[0]\n    var deviceInfo, err2 = os.GetDeviceInfo(firstDevice)\n    if err2 != None {\n        fmt.Println(\"Error getting device info for\", firstDevice, \":\", err2)\n    } else {\n        fmt.Println(\"Device Info for\", firstDevice, \":\", deviceInfo)\n    }\n} else {\n    fmt.Println(\"No devices found to get detailed information.\")\n}\n</code></pre>"},{"location":"error_handling_guide/","title":"Harneet Error Handling System Guide","text":""},{"location":"error_handling_guide/#new-go-style-error-handling-implemented","title":"\ud83c\udf89 NEW: Go-Style Error Handling Implemented!","text":"<p>Harneet now features a comprehensive Go-style error handling system that prevents silent failures and requires explicit error checking. This is a BREAKING CHANGE that makes Harneet programs more reliable and predictable.</p>"},{"location":"error_handling_guide/#key-features","title":"\u2705 Key Features","text":"<ol> <li>Multiple Return Values: Functions return <code>(result, error)</code> tuples</li> <li>Explicit Error Checking: Must check <code>if err != None</code> </li> <li>No Silent Failures: All errors must be handled explicitly</li> <li>Comprehensive Coverage: All standard library functions now return errors</li> <li>None Values: <code>None</code> represents successful operations (no error)</li> </ol>"},{"location":"error_handling_guide/#basic-syntax","title":"\ud83d\udcda Basic Syntax","text":""},{"location":"error_handling_guide/#multiple-return-values","title":"Multiple Return Values","text":"<pre><code>// All stdlib functions now return (result, error) tuples\nvar result, err = math.Max(10, 20)\nvar length, lenErr = strings.Len(\"hello\")\nvar number, parseErr = strings.ToInt(\"42\")\n</code></pre>"},{"location":"error_handling_guide/#error-checking-pattern","title":"Error Checking Pattern","text":"<pre><code>var result, err = someFunction()\nif err != None {\n    // Handle the error\n    fmt.Println(\"Error occurred:\", err)\n    // Could return, exit, or continue with alternative logic\n} else {\n    // Use the result safely\n    fmt.Println(\"Success:\", result)\n}\n</code></pre>"},{"location":"error_handling_guide/#migration-examples","title":"\ud83d\udd04 Migration Examples","text":""},{"location":"error_handling_guide/#before-old-syntax-broken","title":"Before (Old Syntax - BROKEN)","text":"<pre><code>// This will now cause errors!\nvar result = math.Max(10, 20)              // \u274c Wrong\nvar length = strings.Len(\"hello\")          // \u274c Wrong  \nvar maxVal = math.Max(math.Abs(-5), 10)    // \u274c Wrong\n</code></pre>"},{"location":"error_handling_guide/#after-new-syntax-correct","title":"After (New Syntax - CORRECT)","text":"<pre><code>// Correct error handling syntax\nvar result, err = math.Max(10, 20)         // \u2705 Correct\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result)\n}\n\n// Chained operations with error handling\nvar absResult, absErr = math.Abs(-5)\nif absErr != None {\n    fmt.Println(\"Error in abs:\", absErr)  \n} else {\n    var maxResult, maxErr = math.Max(absResult, 10)\n    if maxErr != None {\n        fmt.Println(\"Error in max:\", maxErr)\n    } else {\n        fmt.Println(\"Final result:\", maxResult)\n    }\n}\n</code></pre>"},{"location":"error_handling_guide/#error-handling-patterns","title":"\ud83c\udfdb\ufe0f Error Handling Patterns","text":""},{"location":"error_handling_guide/#pattern-1-simple-error-check","title":"Pattern 1: Simple Error Check","text":"<pre><code>var result, err = math.Abs(-25)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Success:\", result)\n}\n</code></pre>"},{"location":"error_handling_guide/#pattern-2-early-return-simulation","title":"Pattern 2: Early Return (Simulation)","text":"<pre><code>var number, err = strings.ToInt(\"invalid\")\nif err != None {\n    fmt.Println(\"Conversion failed:\", err)\n    // In a real function, you would return here\n    fmt.Println(\"Would return early in a function\")\n} else {\n    fmt.Println(\"Continuing with:\", number)\n}\n</code></pre>"},{"location":"error_handling_guide/#pattern-3-multiple-error-sources","title":"Pattern 3: Multiple Error Sources","text":"<pre><code>var num1, err1 = strings.ToInt(\"25\")\nvar num2, err2 = strings.ToInt(\"30\")\n\nif err1 != None {\n    fmt.Println(\"First conversion failed:\", err1)\n} else if err2 != None {\n    fmt.Println(\"Second conversion failed:\", err2)\n} else {\n    // Both conversions succeeded\n    var sum int = num1 + num2\n    fmt.Println(\"Sum:\", sum)\n}\n</code></pre>"},{"location":"error_handling_guide/#pattern-4-error-propagation-chain","title":"Pattern 4: Error Propagation Chain","text":"<pre><code>// Convert string to number, then find absolute value, then find max\nvar numStr string = \"-42\"\nvar num, numErr = strings.ToInt(numStr)\nif numErr != None {\n    fmt.Println(\"Number conversion failed:\", numErr)\n} else {\n    var abs, absErr = math.Abs(num)\n    if absErr != None {\n        fmt.Println(\"Absolute value failed:\", absErr)\n    } else {\n        var max, maxErr = math.Max(abs, 50)\n        if maxErr != None {\n            fmt.Println(\"Max calculation failed:\", maxErr)\n        } else {\n            fmt.Println(\"Final result:\", max)\n        }\n    }\n}\n</code></pre>"},{"location":"error_handling_guide/#updated-function-signatures","title":"\ud83d\udce6 Updated Function Signatures","text":""},{"location":"error_handling_guide/#math-module","title":"Math Module","text":"Old Signature New Signature <code>math.Abs(x)</code> \u2192 <code>int</code> <code>math.Abs(x)</code> \u2192 <code>(int, error)</code> <code>math.Max(x, y)</code> \u2192 <code>int</code> <code>math.Max(x, y)</code> \u2192 <code>(int, error)</code> <code>math.Min(x, y)</code> \u2192 <code>int</code> <code>math.Min(x, y)</code> \u2192 <code>(int, error)</code> <code>math.Pow(base, exp)</code> \u2192 <code>int</code> <code>math.Pow(base, exp)</code> \u2192 <code>(int, error)</code>"},{"location":"error_handling_guide/#strings-module","title":"Strings Module","text":"Old Signature New Signature <code>strings.Len(s)</code> \u2192 <code>int</code> <code>strings.Len(s)</code> \u2192 <code>(int, error)</code> <code>strings.Upper(s)</code> \u2192 <code>string</code> <code>strings.Upper(s)</code> \u2192 <code>(string, error)</code> <code>strings.Lower(s)</code> \u2192 <code>string</code> <code>strings.Lower(s)</code> \u2192 <code>(string, error)</code> <code>strings.Contains(s, sub)</code> \u2192 <code>int</code> <code>strings.Contains(s, sub)</code> \u2192 <code>(int, error)</code> <code>strings.Replace(s, old, new)</code> \u2192 <code>string</code> <code>strings.Replace(s, old, new)</code> \u2192 <code>(string, error)</code> <code>strings.Split(s, sep)</code> \u2192 <code>string</code> <code>strings.Split(s, sep)</code> \u2192 <code>(string, error)</code> <code>strings.ToInt(s)</code> \u2192 <code>int</code> <code>strings.ToInt(s)</code> \u2192 <code>(int, error)</code>"},{"location":"error_handling_guide/#other-modules","title":"Other Modules","text":"<p>All standard library modules (datetime, os, path, file, log) now follow the same pattern of returning <code>(result, error)</code> tuples.</p>"},{"location":"error_handling_guide/#testing-error-conditions","title":"\ud83e\uddea Testing Error Conditions","text":""},{"location":"error_handling_guide/#valid-operations-no-errors","title":"Valid Operations (No Errors)","text":"<pre><code>var result, err = math.Max(10, 20)\n// result = 20, err = None\n\nvar length, lenErr = strings.Len(\"hello\")  \n// length = 5, lenErr = None\n\nvar number, parseErr = strings.ToInt(\"42\")\n// number = 42, parseErr = None\n</code></pre>"},{"location":"error_handling_guide/#invalid-operations-with-errors","title":"Invalid Operations (With Errors)","text":"<pre><code>var number, err = strings.ToInt(\"not_a_number\")\n// number = None, err = \"cannot convert 'not_a_number' to integer\"\n\n// Note: Math operations typically don't error in current implementation\n// but the infrastructure is there for future enhancements\n</code></pre>"},{"location":"error_handling_guide/#benefits","title":"\u26a1 Benefits","text":"<ol> <li>\ud83d\udee1\ufe0f No Silent Failures: Errors can't be ignored</li> <li>\ud83d\udd0d Clear Error Messages: Descriptive error information  </li> <li>\ud83c\udfd7\ufe0f Reliable Code: Forces proper error handling</li> <li>\ud83d\udccd Error Context: Know exactly what went wrong where</li> <li>\ud83d\ude80 Go-Style Patterns: Familiar to Go developers</li> </ol>"},{"location":"error_handling_guide/#how-to-update-existing-code","title":"\ud83d\udd27 How to Update Existing Code","text":""},{"location":"error_handling_guide/#step-1-identify-function-calls","title":"Step 1: Identify Function Calls","text":"<p>Find all calls to standard library functions: - <code>math.*</code> functions - <code>strings.*</code> functions - <code>datetime.*</code> functions - <code>os.*</code> functions - <code>path.*</code> functions - <code>file.*</code> functions - <code>log.*</code> functions</p>"},{"location":"error_handling_guide/#step-2-update-to-multiple-assignment","title":"Step 2: Update to Multiple Assignment","text":"<pre><code>// Before\nvar result = math.Max(a, b)\n\n// After  \nvar result, err = math.Max(a, b)\nif err != None {\n    // Handle error\n} else {\n    // Use result\n}\n</code></pre>"},{"location":"error_handling_guide/#step-3-handle-chained-operations","title":"Step 3: Handle Chained Operations","text":"<pre><code>// Before (BROKEN)\nvar result = math.Max(math.Abs(x), y)\n\n// After (CORRECT)\nvar absX, absErr = math.Abs(x)\nif absErr != None {\n    // Handle abs error\n} else {\n    var result, maxErr = math.Max(absX, y)\n    if maxErr != None {\n        // Handle max error  \n    } else {\n        // Use result\n    }\n}\n</code></pre>"},{"location":"error_handling_guide/#example-test-program","title":"\ud83e\uddea Example Test Program","text":"<pre><code>import fmt\nimport math\nimport strings\n\nfmt.Println(\"=== Error Handling Demo ===\")\n\n// Test successful operations\nvar maxResult, maxErr = math.Max(15, 30)\nif maxErr != None {\n    fmt.Println(\"Unexpected error:\", maxErr)\n} else {\n    fmt.Println(\"Max result:\", maxResult)\n}\n\n// Test error conditions  \nvar invalidNum, invalidErr = strings.ToInt(\"not_a_number\")\nif invalidErr != None {\n    fmt.Println(\"Expected error:\", invalidErr)\n} else {\n    fmt.Println(\"Unexpected success:\", invalidNum)  \n}\n\n// Test chained operations\nvar numStr string = \"25\"\nvar num, numErr = strings.ToInt(numStr)\nif numErr != None {\n    fmt.Println(\"Conversion error:\", numErr)\n} else {\n    var abs, absErr = math.Abs(num)\n    if absErr != None {\n        fmt.Println(\"Abs error:\", absErr)\n    } else {\n        fmt.Println(\"Chain result:\", abs)\n    }\n}\n\nfmt.Println(\"Demo complete!\")\n</code></pre>"},{"location":"error_handling_guide/#breaking-changes-summary","title":"\ud83d\udea8 Breaking Changes Summary","text":"<ul> <li>\u274c All old code using stdlib functions will break</li> <li>\u2705 Must update to use <code>var result, err = function()</code> syntax </li> <li>\u2705 Must add <code>if err != None</code> checks</li> <li>\u2705 Benefits: Much more reliable and predictable code</li> </ul> <p>This error handling system makes Harneet programs more robust by forcing developers to explicitly handle all potential error conditions, preventing unexpected crashes and silent failures.</p>"},{"location":"error_handling_system/","title":"Error Handling System","text":"<p>Harneet implements a comprehensive Go-style error handling system that emphasizes explicit error checking and prevents silent failures.</p>"},{"location":"error_handling_system/#core-principles","title":"Core Principles","text":"<ol> <li>No Silent Failures: All functions that can fail return an error value.</li> <li>Explicit Error Checking: Errors must be explicitly checked using the <code>if err != None</code> pattern.</li> <li>Multiple Return Values: Functions return <code>(result, error)</code> tuples.</li> <li>Error Propagation: Errors bubble up through the call stack unless handled.</li> </ol>"},{"location":"error_handling_system/#syntax","title":"Syntax","text":""},{"location":"error_handling_system/#multiple-return-values","title":"Multiple Return Values","text":"<pre><code>var result, err = strings.ToInt(\"123\")\nvar content, err = file.Read(\"config.txt\")\nvar x, y, err = someFunction()\n</code></pre>"},{"location":"error_handling_system/#error-checking-pattern","title":"Error Checking Pattern","text":"<pre><code>var value, err = riskyFunction()\nif err != None {\n    fmt.Println(\"Error occurred:\", err)\n    return err // Propagate error up\n}\n// Safe to use value here\nfmt.Println(\"Success:\", value)\n</code></pre>"},{"location":"error_handling_system/#built-in-error-types","title":"Built-in Error Types","text":"<ul> <li>None: Represents no error (similar to Go's nil).</li> <li>Error Values: First-class error objects with descriptive messages.</li> </ul>"},{"location":"error_handling_system/#standard-library-error-handling","title":"Standard Library Error Handling","text":"<p>All standard library functions return errors:</p> <pre><code>// String conversion with error handling\nvar num, err = strings.ToInt(\"invalid\")\nif err != None {\n    fmt.Println(\"Conversion failed:\", err)\n    // Handle error appropriately\n}\n\n// Math operations with error checking\nvar result, err = math.Pow(2, 64) // May overflow\nif err != None {\n    fmt.Println(\"Math error:\", err)\n}\n</code></pre>"},{"location":"error_handling_system/#runtime-assertions","title":"Runtime Assertions","text":"<p>The <code>assert</code> module provides runtime assertions for testing and debugging.</p> <pre><code>import assert\n\n// Development-time checks that panic on failure\nassert.Assert(x &gt; 0, \"x must be positive\")\nassert.AssertEq(actual, expected, \"values should match\")\nassert.AssertNe(result, None, \"result should not be None\")\n</code></pre>"},{"location":"interpreter_architecture/","title":"Harneet Interpreter Architecture Guide","text":"<p>This document explains the core components of the Harneet interpreter and how they work together to execute your code.</p>"},{"location":"interpreter_architecture/#component-overview","title":"Component Overview","text":"<p>The Harneet interpreter follows a traditional pipeline architecture with six main stages:</p> <p>Source Code \u2192 Lexer \u2192 Parser \u2192 AST \u2192 Evaluator (with Standard Library &amp; Stack Trace System) \u2192 Result</p>"},{"location":"interpreter_architecture/#1-lexer-lexergo","title":"1. Lexer (<code>lexer.go</code>)","text":"<p>What it does: The lexer (also called a tokenizer) is the first stage that reads your raw source code character by character and converts it into meaningful tokens.</p> <p>Key responsibilities: - Reads source code as a string of characters - Identifies keywords (<code>var</code>, <code>int</code>, <code>string</code>, <code>if</code>, <code>for</code>, <code>and</code>, <code>or</code>, <code>import</code>, etc.) - Recognizes operators (<code>+</code>, <code>-</code>, <code>==</code>, <code>!=</code>, etc.) - Extracts literals (numbers, strings) - Handles whitespace and comments - Reports the position of each token for error reporting</p> <p>Example transformation:</p> <pre><code>Input:  \"var x int = 42\"\nOutput: [VAR, IDENT(\"x\"), INT, ASSIGN, INTEGER(42)]\n</code></pre> <p>Note: IDENT stands for \"Identifier\" - a user-defined name in your code. <code>IDENT(\"x\")</code> means the lexer found an identifier called \"x\". Identifiers are names you create for variables, functions, or types, as opposed to reserved keywords like <code>var</code>, <code>if</code>, <code>for</code>.</p> <p>Key functions: - <code>NextToken()</code> - Returns the next token from the input stream - Character classification functions to identify token types</p>"},{"location":"interpreter_architecture/#2-parser-parsergo","title":"2. Parser (<code>parser.go</code>)","text":"<p>What it does: The parser takes the stream of tokens from the lexer and organizes them into a structured tree representation (AST) based on the language's grammar rules.</p> <p>Key responsibilities: - Reads tokens in sequence from the lexer - Applies grammar rules to understand syntax structure - Handles operator precedence (e.g., <code>*</code> before <code>+</code>) - Builds the Abstract Syntax Tree (AST) - Reports syntax errors when code doesn't follow grammar rules - Uses recursive descent parsing with Pratt parsing for expressions</p> <p>Example transformation:</p> <pre><code>Input tokens:  [VAR, IDENT(\"x\"), INT, ASSIGN, INTEGER(42)]\nOutput AST:    VarStatement { name: \"x\", type: \"int\", value: 42 }\n</code></pre> <p>Key functions: - <code>parseStatement()</code> - Parses different statement types - <code>parseExpression()</code> - Handles expressions with precedence - Prefix and infix parsing functions for different operators</p>"},{"location":"interpreter_architecture/#3-abstract-syntax-tree-ast-astgo","title":"3. Abstract Syntax Tree (AST) - <code>ast.go</code>","text":""},{"location":"interpreter_architecture/#what-are-ast-trees","title":"What are AST trees?","text":"<p>An Abstract Syntax Tree (AST) is a tree-like data structure that represents the hierarchical structure of your program. Each node in the tree represents a construct in your programming language (like a statement, expression, or operator).</p>"},{"location":"interpreter_architecture/#why-do-we-need-ast-trees","title":"Why do we need AST trees?","text":"<ol> <li> <p>Structure: ASTs provide a clean, organized way to represent the structure of your code, removing unnecessary details like whitespace and focusing on meaning.</p> </li> <li> <p>Language Independence: Once you have an AST, you can process it without worrying about the original syntax - you can evaluate it, compile it, or transform it.</p> </li> <li> <p>Hierarchical Relationships: ASTs naturally represent the precedence and grouping in your code. For example, in <code>2 + 3 * 4</code>, the AST shows that multiplication happens before addition.</p> </li> <li> <p>Easy Processing: Tree structures are easy to traverse recursively, making interpretation and compilation straightforward.</p> </li> </ol> <p>Example AST structure:</p> <pre><code>Program\n\u251c\u2500\u2500 VarStatement\n\u2502   \u251c\u2500\u2500 name: \"x\"\n\u2502   \u251c\u2500\u2500 type: \"int\"\n\u2502   \u2514\u2500\u2500 value: IntegerLiteral(42)\n\u2514\u2500\u2500 AssignStatement\n    \u251c\u2500\u2500 name: \"x\"\n    \u2514\u2500\u2500 value: InfixExpression\n        \u251c\u2500\u2500 left: Identifier(\"x\")\n        \u251c\u2500\u2500 operator: \"+\"\n        \u2514\u2500\u2500 right: IntegerLiteral(10)\n</code></pre> <p>Key node types: - Statements: <code>VarStatement</code>, <code>AssignStatement</code>, <code>IfStatement</code>, <code>ForStatement</code>, <code>ImportStatement</code> - Expressions: <code>Identifier</code>, <code>IntegerLiteral</code>, <code>StringLiteral</code>, <code>InfixExpression</code>, <code>PrefixExpression</code>, <code>CallExpression</code> - Program: Root node containing all statements</p>"},{"location":"interpreter_architecture/#4-evaluator-evaluatorgo","title":"4. Evaluator (<code>evaluator.go</code>)","text":"<p>What it does: The evaluator is a tree-walking interpreter that traverses the AST and executes the program by evaluating each node.</p> <p>Key responsibilities: - Walks through the AST recursively - Maintains program state (variables, their values, imported modules) - Executes operations (arithmetic, comparisons, assignments) - Manages scoping through environments with module support - Handles control flow (if statements, loops) - Processes import statements and resolves standard library functions - Returns results or error objects</p> <p>Key functions: - <code>Eval(Node, *Environment)</code> - Main evaluation function - <code>evalStatement()</code> - Evaluates different statement types - <code>evalExpression()</code> - Evaluates expressions and returns values - Environment management for variable scoping and module imports - Object type conversion between evaluator and standard library systems</p>"},{"location":"interpreter_architecture/#5-standard-library-stdlibgo","title":"5. Standard Library (<code>stdlib.go</code>)","text":"<p>What it does: The standard library provides a collection of built-in modules and functions that extend the language's capabilities without requiring external dependencies.</p> <p>Key responsibilities: - Provides modular functionality through importable modules - Implements commonly needed functions (printing, math, string operations) - Maintains type safety through object conversion - Integrates seamlessly with the evaluator via the environment system</p> <p>Available modules: - fmt: Formatting and printing functions (<code>Println</code>, <code>Print</code>, <code>Printf</code>) - math: Mathematical operations (<code>Abs</code>, <code>Max</code>, <code>Min</code>, <code>Pow</code>) - strings: String manipulation (<code>Len</code>, <code>Upper</code>, <code>Lower</code>, <code>Contains</code>, <code>Replace</code>, <code>Split</code>, <code>ToInt</code>) - datetime: Date, time, and timezone operations with Go-style timers and tickers - os: Operating system integration and device management - path: File path manipulation and utilities - file: File system operations and I/O - log: Structured logging with multiple levels</p> <p>Architecture features: - Modular Design: Each module is self-contained with its own namespace - Type Conversion: Automatic conversion between evaluator and stdlib object types - Extensible: Easy to add new modules and functions - Import System: Functions only available after importing the containing module</p> <p>Key functions: - <code>GetModule(name)</code> - Retrieves a module by name - Module function registration and execution - Object type conversion (<code>evalToStdlib</code>, <code>stdlibToEval</code>) - Built-in function wrappers for seamless integration</p>"},{"location":"interpreter_architecture/#6-stack-trace-system-error-debugging","title":"6. Stack Trace System (Error Debugging)","text":"<p>What it does: The stack trace system provides comprehensive error debugging information, including precise source locations and function call hierarchies, making it much easier to diagnose and fix runtime errors.</p> <p>Key responsibilities: - Position Tracking: All AST nodes maintain their exact source position (file, line, column) - Call Stack Management: Environment tracks the complete function call hierarchy - Error Enhancement: Runtime errors include detailed stack trace information - Source Context: File names and positions are preserved throughout execution</p>"},{"location":"interpreter_architecture/#architecture-components","title":"Architecture Components","text":""},{"location":"interpreter_architecture/#a-position-information-parserastgo","title":"A. Position Information (<code>parser/ast.go</code>)","text":"<p>Every AST node includes a <code>Position</code> struct:</p> <pre><code>type Position struct {\n    Line     int    // Line number in source file\n    Column   int    // Column position on the line  \n    Filename string // Source file path\n}\n\ntype Node interface {\n    String() string\n    Pos() Position  // All nodes provide their position\n}\n</code></pre>"},{"location":"interpreter_architecture/#b-stack-frame-tracking-evaluatorgo","title":"B. Stack Frame Tracking (<code>evaluator.go</code>)","text":"<p>The evaluator maintains a call stack using <code>StackFrame</code> structures:</p> <pre><code>type StackFrame struct {\n    Function string          // Function name (\"&lt;program&gt;\" for top-level)\n    Position parser.Position // Exact source location\n    Source   string          // Source code context (future enhancement)\n}\n</code></pre>"},{"location":"interpreter_architecture/#c-enhanced-error-objects","title":"C. Enhanced Error Objects","text":"<p>Error objects include complete stack trace information:</p> <pre><code>type Error struct {\n    Message    string       // The actual error message\n    StackTrace []StackFrame // Complete call stack at error time\n}\n</code></pre>"},{"location":"interpreter_architecture/#d-environment-call-stack-management","title":"D. Environment Call Stack Management","text":"<p>The <code>Environment</code> maintains the active call stack:</p> <pre><code>type Environment struct {\n    store     map[string]Object\n    modules   map[string]*stdlib.Module\n    outer     *Environment\n    callStack []StackFrame          // Tracks function calls\n}\n</code></pre>"},{"location":"interpreter_architecture/#implementation-flow","title":"Implementation Flow","text":""},{"location":"interpreter_architecture/#step-1-position-tracking-during-parsing","title":"Step 1: Position Tracking During Parsing","text":"<ol> <li>Lexer Enhancement: Tokens include filename, line, and column information</li> <li>Parser Enhancement: All AST node creation includes position from tokens</li> <li>Helper Function: <code>posFromToken()</code> converts token position to AST position</li> </ol>"},{"location":"interpreter_architecture/#step-2-call-stack-management-during-evaluation","title":"Step 2: Call Stack Management During Evaluation","text":"<ol> <li>Initial Frame: Environment starts with <code>&lt;program&gt;</code> frame</li> <li>Function Calls: <code>PushFrame()</code> adds new stack frame when calling functions</li> <li>Position Updates: Current frame position updated as evaluation progresses</li> <li>Frame Cleanup: <code>PopFrame()</code> removes frames when functions complete</li> </ol>"},{"location":"interpreter_architecture/#step-3-error-creation-with-stack-traces","title":"Step 3: Error Creation with Stack Traces","text":"<ol> <li>Stack-Aware Errors: <code>newErrorWithStack()</code> captures current call stack</li> <li>Error Propagation: Errors bubble up maintaining their stack trace</li> <li>Formatted Output: Stack traces display with clear formatting</li> </ol>"},{"location":"interpreter_architecture/#position-flow-example","title":"Position Flow Example","text":"<p>Source Code: <code>examples/error.ha</code></p> <pre><code>import math\nvar result = math.Max(42, 10 / 0)  // Division by zero error\n</code></pre> <p>Position Tracking Flow:</p> <pre><code>1. Lexer: Creates tokens with filename \"examples/error.ha\"\n2. Parser: AST nodes inherit position from tokens:\n   - VarStatement at error.ha:2:0\n   - CallExpression at error.ha:2:14  \n   - InfixExpression (/) at error.ha:2:27\n3. Evaluator: Updates call stack positions during execution:\n   - &lt;program&gt; frame: error.ha:2:14 (when evaluating var statement)\n   - math.Max frame: error.ha:2:33 (when calling function)\n4. Error Creation: Division by zero creates error with both frames\n</code></pre> <p>Output Stack Trace:</p> <pre><code>ERROR: division by zero\nStack trace:\n  at &lt;program&gt; (examples/error.ha:2:14)\n  at math.Max (examples/error.ha:2:33)\n</code></pre>"},{"location":"interpreter_architecture/#key-implementation-details","title":"Key Implementation Details","text":""},{"location":"interpreter_architecture/#a-filename-propagation","title":"A. Filename Propagation","text":"<ul> <li>Lexer: <code>NewWithFilename()</code> accepts filename parameter</li> <li>Token Creation: All tokens include source filename</li> <li>Environment: <code>SetProgramFilename()</code> ensures program frame has filename</li> <li>Position Preservation: Evaluation preserves filename across all frames</li> </ul>"},{"location":"interpreter_architecture/#b-smart-position-updates","title":"B. Smart Position Updates","text":"<p>The evaluator intelligently updates positions:</p> <pre><code>if nodePos.Filename != \"\" {\n    // Use complete position information\n    env.callStack[top].Position = nodePos\n} else {\n    // Preserve filename, update line/column only\n    env.callStack[top].Position.Line = nodePos.Line\n    env.callStack[top].Position.Column = nodePos.Column\n}\n</code></pre>"},{"location":"interpreter_architecture/#c-function-call-tracking","title":"C. Function Call Tracking","text":"<p>Standard library function calls are tracked:</p> <pre><code>// Add function call to stack trace\nenv.PushFrame(functionName, node.Pos())\ndefer env.PopFrame()\n\n// Execute function with tracked context\nresult := builtin.Fn(args...)\n</code></pre>"},{"location":"interpreter_architecture/#error-types-with-stack-traces","title":"Error Types with Stack Traces","text":""},{"location":"interpreter_architecture/#1-arithmetic-errors","title":"1. Arithmetic Errors","text":"<ul> <li>Division by Zero: Shows exact location of division operation</li> <li>Modulo by Zero: Includes stack context for debugging</li> </ul>"},{"location":"interpreter_architecture/#2-identifier-errors","title":"2. Identifier Errors","text":"<ul> <li>Undefined Variables: Shows where undefined identifier was accessed</li> <li>Scope Issues: Stack trace helps identify scoping problems</li> </ul>"},{"location":"interpreter_architecture/#3-function-call-errors","title":"3. Function Call Errors","text":"<ul> <li>Invalid Arguments: Shows both call site and function entry</li> <li>Nested Calls: Complete call hierarchy for complex expressions</li> </ul>"},{"location":"interpreter_architecture/#4-type-conversion-errors","title":"4. Type Conversion Errors","text":"<ul> <li>String to Int: Standard library calls show full context</li> <li>Module Errors: Import and function resolution issues</li> </ul>"},{"location":"interpreter_architecture/#5-parser-errors-syntax-errors","title":"5. Parser Errors (Syntax Errors)","text":"<ul> <li>Incomplete Expressions: Shows \"monkey business\" message with stack trace information</li> <li>Invalid Syntax: Token parsing errors include detailed diagnostic information</li> <li>Grammar Violations: Comprehensive error reporting during compilation phase</li> </ul>"},{"location":"interpreter_architecture/#benefits-for-debugging","title":"Benefits for Debugging","text":""},{"location":"interpreter_architecture/#immediate-error-location","title":"Immediate Error Location","text":"<pre><code>Before: \"ERROR: division by zero\"\nAfter:  \"ERROR: division by zero\n         Stack trace:\n           at &lt;program&gt; (myfile.ha:5:22)\"\n</code></pre>"},{"location":"interpreter_architecture/#function-call-context","title":"Function Call Context","text":"<pre><code>Before: Hard to trace nested function calls\nAfter:  Shows complete call hierarchy:\n        at &lt;program&gt; (myfile.ha:5:14)\n        at math.Max (myfile.ha:5:33)\n</code></pre>"},{"location":"interpreter_architecture/#file-context","title":"File Context","text":"<pre><code>Before: No way to know which file caused error\nAfter:  Exact file path in every stack frame\n</code></pre>"},{"location":"interpreter_architecture/#parser-error-diagnostics","title":"Parser Error Diagnostics","text":"<pre><code>Before: Basic syntax error messages\nAfter:  \"Woops! Sincere apologies, but we ran into some errors while running the program!\n         Stack trace:\n          parser errors:\n            no prefix parse function for DIVIDE found\n            no prefix parse function for ERROR_TYPE found\"\n</code></pre>"},{"location":"interpreter_architecture/#testing-infrastructure","title":"Testing Infrastructure","text":""},{"location":"interpreter_architecture/#test-files","title":"Test Files","text":"<ul> <li><code>examples/simple_stack_trace_test.ha</code> - Basic error scenarios</li> <li><code>examples/nested_function_error_test.ha</code> - Function call hierarchies  </li> <li><code>examples/identifier_error_test.ha</code> - Variable access errors</li> <li><code>examples/stacktrace_test.ha</code> - Comprehensive error testing</li> <li><code>examples/parser_error_test.ha</code> - Parser error diagnostic testing</li> </ul>"},{"location":"interpreter_architecture/#test-commands","title":"Test Commands","text":"<ul> <li><code>just test-stacktrace</code> - Dedicated stack trace testing</li> <li><code>just test</code> - Includes stack trace tests in full suite</li> </ul>"},{"location":"interpreter_architecture/#test-output-validation","title":"Test Output Validation","text":"<p>Tests verify that stack traces include: - Correct file names and paths - Accurate line and column numbers - Complete function call hierarchies - Proper error message formatting</p>"},{"location":"interpreter_architecture/#control-flow-between-components","title":"Control Flow Between Components","text":"<p>Here's how the components work together when you run a Harneet program:</p>"},{"location":"interpreter_architecture/#step-1-lexical-analysis","title":"Step 1: Lexical Analysis","text":"<pre><code>Source: \"import fmt\\nvar x int = 42\\nfmt.Println(x + 8)\"\n\u2193 (Lexer processes character by character)\nTokens: [IMPORT, IDENT(\"fmt\"), NEWLINE, VAR, IDENT(\"x\"), INT, ASSIGN, INTEGER(42), NEWLINE, IDENT(\"fmt\"), DOT, IDENT(\"Println\"), LPAREN, IDENT(\"x\"), PLUS, INTEGER(8), RPAREN]\n</code></pre>"},{"location":"interpreter_architecture/#step-2-syntax-analysis","title":"Step 2: Syntax Analysis","text":"<pre><code>Tokens \u2192 Parser\n\u2193 (Parser applies grammar rules)\nAST: Program {\n  statements: [\n    ImportStatement { module: Identifier(\"fmt\") },\n    VarStatement { name: \"x\", type: \"int\", value: IntegerLiteral(42) },\n    ExpressionStatement { \n      expression: CallExpression {\n        function: InfixExpression { left: Identifier(\"fmt\"), operator: \".\", right: Identifier(\"Println\") },\n        arguments: [\n          InfixExpression { left: Identifier(\"x\"), operator: \"+\", right: IntegerLiteral(8) }\n        ]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"interpreter_architecture/#step-3-evaluation","title":"Step 3: Evaluation","text":"<pre><code>AST \u2192 Evaluator (with Standard Library support)\n\u2193 (Evaluator walks the tree)\n1. Execute ImportStatement: Import fmt module from standard library\n2. Execute VarStatement: Create variable \"x\" with value 42\n3. Execute CallExpression:\n   - Resolve \"fmt.Println\" to standard library function\n   - Evaluate argument: x + 8 = 42 + 8 = 50\n   - Convert evaluator objects to stdlib objects\n   - Call fmt.Println(50) from standard library\n   - Convert result back to evaluator objects\n   - Output: \"50\"\n</code></pre>"},{"location":"interpreter_architecture/#data-flow-summary","title":"Data Flow Summary","text":"<ol> <li>Lexer: Raw text \u2192 Tokens (with position information)</li> <li>Parser: Tokens \u2192 AST (structured representation with source positions)</li> <li>Evaluator: AST \u2192 Execution (with side effects like printing, variable changes)</li> <li>Standard Library: Provides modular built-in functionality through import system</li> <li>Stack Trace System: Tracks execution context and provides detailed error information</li> </ol> <p>Each component has a single responsibility and passes its output to the next stage, creating a clean separation of concerns that makes the interpreter easier to understand, debug, and extend. The stack trace system operates as a cross-cutting concern, enhancing error reporting throughout the pipeline.</p>"},{"location":"interpreter_architecture/#module-import-and-resolution-flow","title":"Module Import and Resolution Flow","text":"<p>When a program uses <code>import fmt</code> and calls <code>fmt.Println()</code>:</p> <ol> <li>Import Processing: ImportStatement node causes evaluator to load fmt module into environment</li> <li>Function Resolution: CallExpression with dot notation resolves to standard library function</li> <li>Type Conversion: Arguments converted from evaluator objects to stdlib objects</li> <li>Function Execution: Standard library function executes with converted arguments</li> <li>Result Conversion: Function result converted back to evaluator object system</li> </ol>"},{"location":"interpreter_architecture/#environment-and-scoping","title":"Environment and Scoping","text":"<p>The evaluator uses an <code>Environment</code> struct to manage variable scoping and module imports: - Each scope (global, function, block) has its own environment - Environments can be nested (inner scopes can access outer variables) - Variable lookup searches from innermost to outermost scope - Module registry tracks imported modules and their available functions - Import statements load modules into the current environment's module registry - Function calls with dot notation resolve through the module system</p> <p>This architecture makes it relatively straightforward to add new language features by: 1. Adding new token types to the lexer 2. Adding parsing rules to the parser 3. Adding new AST node types 4. Adding evaluation logic to the evaluator 5. Extending the standard library with new modules and functions (for built-in functionality)</p>"},{"location":"interpreter_architecture/#adding-new-standard-library-modules","title":"Adding New Standard Library Modules","text":"<p>The modular standard library design makes it easy to add new functionality:</p>"},{"location":"interpreter_architecture/#step-1-define-module-functions","title":"Step 1: Define Module Functions","text":"<pre><code>func newModule() *Module {\n    return &amp;Module{\n        Name: \"modulename\",\n        Functions: map[string]*BuiltinFunction{\n            \"FunctionName\": {\n                Name: \"FunctionName\",\n                Fn: func(args ...Object) Object {\n                    // Implementation here\n                    return result\n                },\n            },\n        },\n    }\n}\n</code></pre>"},{"location":"interpreter_architecture/#step-2-register-module","title":"Step 2: Register Module","text":"<pre><code>var Modules = map[string]*Module{\n    \"fmt\":        fmtModule(),\n    \"math\":       mathModule(), \n    \"strings\":    stringsModule(),\n    \"modulename\": newModule(),  // Add new module\n}\n</code></pre>"},{"location":"interpreter_architecture/#step-3-use-in-harneet-code","title":"Step 3: Use in Harneet Code","text":"<pre><code>import modulename\nvar result = modulename.FunctionName(args)\n</code></pre> <p>This design provides: - Type Safety: Automatic object conversion between systems - Namespace Isolation: Each module has its own function namespace - Easy Testing: Modules can be tested independently - Clean Integration: No changes needed to core interpreter components</p>"},{"location":"interpreter_architecture/#advanced-standard-library-architecture","title":"Advanced Standard Library Architecture","text":""},{"location":"interpreter_architecture/#complex-object-types-and-state-management","title":"Complex Object Types and State Management","text":"<p>The Harneet interpreter supports advanced object types beyond basic primitives, enabling sophisticated functionality like Go-style timers and tickers. These complex objects require special handling for state management and resource cleanup.</p>"},{"location":"interpreter_architecture/#timer-and-ticker-object-architecture","title":"Timer and Ticker Object Architecture","text":"<p>Object Type System Extension:</p> <pre><code>// Standard Library Object Types\nconst (\n    INTEGER_OBJ   = \"INTEGER\"\n    STRING_OBJ    = \"STRING\" \n    BOOLEAN_OBJ   = \"BOOLEAN\"\n    TICKER_OBJ    = \"TICKER\"    // Go-style periodic events\n    TIMER_OBJ     = \"TIMER\"     // Go-style delayed events\n)\n</code></pre> <p>Complex Object Implementations:</p> <pre><code>type Ticker struct {\n    ID         string\n    Interval   int64\n    C          chan time.Time\n    ticker     *time.Ticker\n}\n\ntype Timer struct {\n    ID      string\n    Delay   int64\n    C       chan time.Time\n    timer   *time.Timer\n    fired   bool\n}\n</code></pre>"},{"location":"interpreter_architecture/#global-state-management","title":"Global State Management","text":"<p>Resource Tracking: The standard library maintains global state for managing active timers and tickers:</p> <pre><code>var (\n    activeTickers = make(map[string]*Ticker)\n    activeTimers  = make(map[string]*Timer)\n    mu            sync.Mutex  // Thread safety for resource access\n)\n</code></pre> <p>Resource Lifecycle Management: 1. Creation: Objects stored in global maps with unique string IDs 2. Access: Non-blocking channel operations for event checking 3. Cleanup: Explicit resource cleanup with Stop functions 4. Memory Safety: Automatic cleanup prevents resource leaks</p>"},{"location":"interpreter_architecture/#cross-system-object-conversion","title":"Cross-System Object Conversion","text":"<p>Evaluator-to-Standard Library Conversion:</p> <pre><code>func evalToStdlib(obj evaluator.Object) Object {\n    switch o := obj.(type) {\n    case *evaluator.Ticker:\n        return &amp;Ticker{\n            ID:       o.ID,\n            Interval: o.Interval,\n        }\n    case *evaluator.Timer:\n        return &amp;Timer{\n            ID:    o.ID,\n            Delay: o.Delay,\n            fired: o.fired,\n        }\n    }\n}\n</code></pre> <p>Standard Library-to-Evaluator Conversion:</p> <pre><code>func stdlibToEval(obj Object) evaluator.Object {\n    switch o := obj.(type) {\n    case *Ticker:\n        return &amp;evaluator.Ticker{\n            ID:       o.ID,\n            Interval: o.Interval,\n        }\n    case *Timer:\n        return &amp;evaluator.Timer{\n            ID:    o.ID,\n            Delay: o.Delay,\n            fired: o.fired,\n        }\n    }\n}\n</code></pre>"},{"location":"interpreter_architecture/#timezone-and-locale-management","title":"Timezone and Locale Management","text":"<p>International Support Architecture:</p> <pre><code>var localeToTZ = map[string]string{\n    \"US\": \"America/New_York\",    \"UK\": \"Europe/London\",\n    \"DE\": \"Europe/Berlin\",       \"FR\": \"Europe/Paris\",\n    \"JP\": \"Asia/Tokyo\",          \"AU\": \"Australia/Sydney\",\n    \"IN\": \"Asia/Kolkata\",        \"CN\": \"Asia/Shanghai\",\n    \"BR\": \"America/Sao_Paulo\",   \"CA\": \"America/Toronto\",\n    \"RU\": \"Europe/Moscow\",       \"MX\": \"America/Mexico_City\",\n}\n</code></pre> <p>Cross-Platform Timezone Operations: - IANA Database Integration: Uses Go's time.LoadLocation for standard timezone support - System Timezone Detection: Automatic detection of current system timezone - Offset Calculations: UTC offset computation for any timezone - Locale Mapping: Country-code to timezone resolution</p>"},{"location":"interpreter_architecture/#error-handling-integration","title":"Error Handling Integration","text":"<p>Go-Style Error Handling with Standard Library: All standard library functions return <code>(result, error)</code> tuples:</p> <pre><code>func ToInt(args ...Object) Object {\n    if len(args) != 1 {\n        return NewTuple(nil, NewError(\"ToInt() takes exactly 1 argument\"))\n    }\n\n    str, ok := args[0].(*String)\n    if !ok {\n        return NewTuple(nil, NewError(\"ToInt() argument must be a string\"))\n    }\n\n    value, err := strconv.Atoi(str.Value)\n    if err != nil {\n        return NewTuple(nil, NewError(fmt.Sprintf(\"cannot convert '%s' to int\", str.Value)))\n    }\n\n    return NewTuple(NewInteger(int64(value)), nil)\n}\n</code></pre> <p>Stack Trace Integration: Standard library errors include complete call stack information:</p> <pre><code>func (env *Environment) CallBuiltin(name string, node parser.Node, args ...Object) Object {\n    env.PushFrame(name, node.Pos())\n    defer env.PopFrame()\n\n    result := builtin.Fn(args...)\n\n    if errorObj, ok := result.(*Error); ok {\n        errorObj.StackTrace = env.GetCallStack()\n    }\n\n    return result\n}\n</code></pre>"},{"location":"interpreter_architecture/#module-registration-and-discovery","title":"Module Registration and Discovery","text":"<p>Dynamic Module System:</p> <pre><code>var Modules = map[string]*Module{\n    \"fmt\":      fmtModule(),\n    \"math\":     mathModule(),\n    \"strings\":  stringsModule(),\n    \"datetime\": datetimeModule(),\n    \"os\":       osModule(),\n    \"path\":     pathModule(),\n    \"file\":     fileModule(),\n    \"log\":      logModule(),\n}\n\nfunc GetModule(name string) (*Module, bool) {\n    module, exists := Modules[name]\n    return module, exists\n}\n</code></pre> <p>Extensible Function Registration:</p> <pre><code>func datetimeModule() *Module {\n    return &amp;Module{\n        Name: \"datetime\",\n        Functions: map[string]*BuiltinFunction{\n            \"Now\":        {Name: \"Now\", Fn: datetimeNow},\n            \"ConvertTZ\":  {Name: \"ConvertTZ\", Fn: datetimeConvertTZ},\n            \"NewTimer\":   {Name: \"NewTimer\", Fn: datetimeNewTimer},\n            \"NewTicker\":  {Name: \"NewTicker\", Fn: datetimeNewTicker},\n            // ... additional functions\n        },\n    }\n}\n</code></pre>"},{"location":"interpreter_architecture/#testing-infrastructure-for-complex-objects","title":"Testing Infrastructure for Complex Objects","text":"<p>Comprehensive Test Coverage: - Timer functionality: Creation, checking, firing, stopping - Ticker functionality: Periodic events, cleanup - Timezone operations: Conversion, locale resolution - Error handling: Invalid arguments, resource management</p> <p>Test File Organization:</p> <pre><code>examples/\n\u251c\u2500\u2500 datetime_comprehensive_test.ha  # Full feature coverage\n\u251c\u2500\u2500 datetime_timer_test.ha          # Timer-specific testing  \n\u251c\u2500\u2500 datetime_ticker_test.ha         # Ticker-specific testing\n\u251c\u2500\u2500 datetime_timezone_test.ha       # Timezone operations\n\u2514\u2500\u2500 os_comprehensive_test.ha        # OS module functionality\n</code></pre>"},{"location":"language_spec/","title":"Harneet - Comprehensive Language Specification","text":""},{"location":"language_spec/#overview","title":"Overview","text":"<p>Harneet is a modern interpreted programming language inspired by Go's clean syntax, featuring comprehensive type safety, Unicode support, advanced standard library, and sophisticated error handling. It combines the simplicity of Go with Python-style ergonomics and modern language features.</p>"},{"location":"language_spec/#core-language-features","title":"Core Language Features","text":""},{"location":"language_spec/#module-system-standard-library","title":"Module System &amp; Standard Library","text":""},{"location":"language_spec/#import-system","title":"Import System","text":"<ul> <li>Single Import: <code>import fmt</code>, <code>import math</code></li> <li>Multiple Imports: <code>import fmt, math, strings</code></li> <li>Import Aliases: <code>import fmt as format</code>, <code>import datetime as dt</code></li> <li>Import Validation: Automatic detection of unused and duplicate imports</li> <li>Module Resolution: Intelligent module resolution with helpful error messages</li> </ul>"},{"location":"language_spec/#available-modules-12-built-in-modules","title":"Available Modules (12 Built-in Modules)","text":"<p>fmt - Console output and formatting - <code>Println(args...)</code> - Print with newline - <code>Print(args...)</code> - Print without newline - <code>Printf(format, args...)</code> - Formatted printing with placeholders - <code>Errorf(format, args...)</code> - Create formatted error message</p> <p>math - Mathematical operations - <code>Abs(number)</code> - Absolute value of number - <code>Max(a, b)</code> - Maximum of two numbers - <code>Min(a, b)</code> - Minimum of two numbers - <code>Pow(base, exponent)</code> - Power/exponentiation</p> <p>strings - String manipulation functions - <code>Len(string)</code> - Get string length - <code>Upper(string)</code> - Convert to uppercase - <code>Lower(string)</code> - Convert to lowercase - <code>Contains(string, substring)</code> - Check if string contains substring - <code>Replace(string, old, new)</code> - Replace substring occurrences - <code>Split(string, separator)</code> - Split string into array - <code>ToInt(string)</code> - Parse string to integer</p> <p>arrays - Comprehensive array operations (14+ functions) - <code>length(array)</code> - Get array length - <code>contains(array, value)</code> - Check if array contains value - <code>index(array, value)</code> - Find index of value in array - <code>push(array, value)</code> - Add element to end of array - <code>pop(array)</code> - Remove and return last element - <code>replace(array, index, value)</code> - Replace element at specific index - <code>delete(array, index)</code> - Remove element at specific index - <code>copy(array)</code> - Create shallow copy of array - <code>clear(array)</code> - Remove all elements from array - <code>equal(array1, array2)</code> - Compare arrays for equality - <code>sort(array)</code> - Sort array elements - <code>memory(array)</code> - Get memory usage information - <code>tojson(array)</code> - Convert array to JSON string - <code>tostring(array)</code> - Convert array to string representation</p> <p>datetime - Date and time operations with comprehensive timezone support - <code>Now()</code> - Get current timestamp in Unix format - <code>Format(timestamp, format)</code> - Format timestamp using specified format strings - <code>Sleep(seconds)</code> - Pause execution for specified duration - <code>Year(timestamp)</code>, <code>Month(timestamp)</code>, <code>Day(timestamp)</code> - Extract date components - <code>ConvertTZ(timestamp, fromTZ, toTZ)</code> - Convert between timezones using IANA identifiers - <code>NowInTZ(timezone)</code> - Get current time in specified timezone - <code>LocalTime(locale)</code> - Get current time for country locale with expanded global coverage (33 locales) - <code>GetSystemTZ()</code> - Get system timezone name - <code>GetTZOffset(timezone)</code> - Get timezone offset from UTC in seconds - <code>NewTimer(id, delay_seconds)</code> - Create delayed event timer with string ID - <code>CheckTimer(id)</code> - Non-blocking check if timer has fired - <code>StopTimer(id)</code> - Stop and remove timer - <code>NewTicker(id, interval_seconds)</code> - Create periodic event ticker with string ID - <code>StopTicker(id)</code> - Stop and remove ticker - <code>IsValidCron(expression)</code> - Validate cron expression format - <code>NextCronExecution(expression, timestamp)</code> - Calculate next execution time - <code>ParseCron(expression)</code> - Parse cron expression returning CronJob object - <code>ScheduleCron(id, expression)</code> - Schedule recurring job with unique ID - <code>StopCron(id)</code> - Stop scheduled cron job by ID - <code>ListCronJobs()</code> - List all active cron job IDs - <code>EveryMinute()</code>, <code>Hourly()</code>, <code>Daily()</code>, <code>Weekly()</code>, <code>Monthly()</code> - Common cron patterns</p> <p>os - Operating system interface - <code>Getenv(name)</code> - Get environment variable - <code>Setenv(name, value)</code> - Set environment variable - <code>Type()</code> - Get operating system type - <code>Version()</code> - Get OS version information - <code>Arch()</code> - Get system architecture - <code>Getwd()</code> - Get current working directory - <code>Chdir(path)</code> - Change current directory - <code>Mkdir(path)</code> - Create directory - <code>Remove(path)</code> - Remove file or directory - <code>Exists(path)</code> - Check if path exists - <code>ListDevices()</code> - List system devices - <code>GetDeviceInfo(device)</code> - Get device information</p> <p>path - File path manipulation - <code>Join(parts...)</code> - Join path components - <code>Dir(path)</code> - Get directory portion of path - <code>Base(path)</code> - Get filename portion of path - <code>Ext(path)</code> - Get file extension - <code>Abs(path)</code> - Get absolute path - Path cleaning and normalization functions</p> <p>file - File I/O operations - <code>Read(filename)</code> - Read entire file contents - <code>Write(filename, content)</code> - Write content to file - <code>Append(filename, content)</code> - Append content to file - <code>Copy(src, dest)</code> - Copy file from source to destination - <code>Size(filename)</code> - Get file size in bytes - File metadata and permissions handling</p> <p>log - Structured logging system - <code>Info(message)</code> - Log at info level - <code>Warn(message)</code> - Log at warning level - <code>Error(message)</code> - Log at error level - <code>Debug(message)</code> - Log at debug level - Configurable log levels and output formatting</p> <p>errors - Error creation and handling - <code>New(message)</code> - Create new error with message - <code>Errorf(format, args...)</code> - Create formatted error message - Integration with Go-style error handling patterns</p> <p>json - RFC 8259 compliant JSON operations - <code>Marshal(value)</code> - Convert value to JSON string - <code>Unmarshal(json_string)</code> - Parse JSON string to value - <code>Valid(json_string)</code> - Check if string is valid JSON - <code>Indent(json, prefix, indent)</code> - Format JSON with indentation - Full support for all JSON data types and structures</p> <p>assert - Runtime assertions for testing and debugging - <code>Assert(condition, message?)</code> - Assert condition is true, panic if false - <code>AssertEq(actual, expected, message?)</code> - Assert equality - <code>AssertNe(actual, expected, message?)</code> - Assert inequality - Rust-style panic behavior with helpful error messages</p>"},{"location":"language_spec/#module-usage","title":"Module Usage","text":"<pre><code>import fmt, math, strings, arrays\n\n// Use functions with module prefix\nfmt.Println(\"Hello World\")\nvar result, err = math.Abs(-42)\nvar nums = [1, 2, 3, 4, 5]\nvar length, _ = arrays.length(nums)\n</code></pre>"},{"location":"language_spec/#operators-expressions","title":"Operators &amp; Expressions","text":"<ul> <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (addition, subtraction, multiplication, division, modulo)</li> <li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> (equality, inequality, relational)</li> <li>Logical: <code>and</code>, <code>or</code>, <code>not</code> (Python-style with short-circuit evaluation)</li> <li>Assignment: <code>=</code> (assignment), <code>:=</code> (short declaration and assignment)</li> <li>String Concatenation: <code>+</code> operator for joining strings</li> <li>Precedence: Standard mathematical precedence with parentheses for grouping</li> </ul>"},{"location":"language_spec/#user-defined-functions","title":"User-Defined Functions","text":""},{"location":"language_spec/#function-declaration-syntax","title":"Function Declaration Syntax","text":"<pre><code>function functionName(param1 type1, param2 type2) returnType {\n    // function body\n    return value\n}\n</code></pre>"},{"location":"language_spec/#function-examples","title":"Function Examples","text":"<pre><code>// Function with single return\nfunction square(x int) int {\n    return x * x\n}\n\n// Function with multiple returns\nfunction divide(a, b float64) (float64, string) {\n    if b == 0 {\n        return 0.0, \"division by zero\"\n    }\n    return a / b, \"\"\n}\n\n// Function with no parameters\nfunction getAnswer() int {\n    return 42\n}\n\n// Function with no return type\nfunction printMessage() {\n    fmt.Println(\"Hello, Harneet!\")\n}\n</code></pre>"},{"location":"language_spec/#arrow-functions-es6-style","title":"Arrow Functions (ES6-Style)","text":"<pre><code>// Single parameter (parentheses optional)\nvar double = x =&gt; x * 2\n\n// Multiple parameters (parentheses required)\nvar add = (a, b) =&gt; a + b\n\n// Block body with explicit return\nvar complex = (x, y) =&gt; {\n    var result = x + y\n    return result * 2\n}\n</code></pre>"},{"location":"language_spec/#advanced-language-features","title":"Advanced Language Features","text":""},{"location":"language_spec/#comments","title":"Comments","text":"<pre><code>// Line comment - single line\n/* Block comment - can span\n   multiple lines and supports\n   Unicode characters: \u4f60\u597d \ud83c\udf0d */\n</code></pre>"},{"location":"language_spec/#unicode-support","title":"Unicode Support","text":"<pre><code>var greeting = \"Hello \u4e16\u754c \ud83c\udf0d\"\nvar chinese = \"\u4f60\u597d\u4e16\u754c\"\nvar emoji = \"\ud83c\udf89 Celebration time! \ud83c\udf8a\"\nfmt.Println(greeting)  // Full Unicode display support\n</code></pre>"},{"location":"language_spec/#example-program","title":"Example Program","text":"<pre><code>import fmt, math, strings\n\n// Both explicit and inferred types supported\nvar x int = 10          // explicit type\nvar name = \"Harneet\"    // type inferred as string\ny := 5                  // short declaration with inference\nresult := x + y * 2\n\nfmt.Println(\"Result:\", result)\nfmt.Println(\"Name:\", name)\n\n// Multiple assignment examples\nvar firstName, lastName, age = \"John\", \"Doe\", 30\nfmt.Println(\"User:\", firstName, lastName, \"Age:\", age)\n\n// Error handling example\nvar absValue, err = math.Abs(-25)\nif err != None {\n    fmt.Println(\"Math error:\", err.Error())\n} else {\n    fmt.Println(\"Absolute value:\", absValue)\n}\n\nif result &gt; 15 {\n    fmt.Println(\"Large result\")\n} else if result &gt; 10 {\n    fmt.Println(\"Medium result\")\n} else {\n    fmt.Println(\"Small result\")\n}\n\nfor i := 0; i &lt; 3; i = i + 1 {\n    fmt.Println(\"Loop iteration:\", i)\n}\n\n// Switch statement example\nday := 2\nswitch day {\ncase 1 {\n    fmt.Println(\"Monday\")\n}\ncase 2, 3 {\n    fmt.Println(\"Tuesday or Wednesday\")\n}\ncase 4, 5 {\n    fmt.Println(\"Thursday or Friday\")\n}\ndefault {\n    fmt.Println(\"Weekend\")\n}\n}\n\n// Standard library functions\nfmt.Println(\"Absolute value:\", math.Abs(-42))\nfmt.Println(\"String length:\", strings.Len(name))\nfmt.Println(\"Uppercase:\", strings.Upper(name))\n\n// Logical operators (Python-style)\na := 5\nb := 0\nfmt.Println(\"a and b:\", a and b)  // Returns 0 (first falsy value)\nfmt.Println(\"a or b:\", a or b)    // Returns 5 (first truthy value)\nfmt.Println(\"not a:\", not a)      // Returns false (5 is truthy)\nfmt.Println(\"not b:\", not b)      // Returns true (0 is falsy)\n</code></pre>"},{"location":"language_spec/#token-types","title":"Token Types","text":"<ul> <li>NUMBER: Integer literals</li> <li>STRING: String literals  </li> <li>IDENTIFIER: Variable names</li> <li>KEYWORD: Reserved words (var, int, string, error, if, else, for, import, None, switch, case, default, etc.)</li> <li>OPERATOR: Arithmetic and comparison operators</li> <li>ASSIGN: Assignment operators (=, :=)</li> <li>LBRACE/RBRACE: Block delimiters ({ })</li> <li>LPAREN/RPAREN: Parentheses</li> <li>DOT: Member access (.)</li> <li>COMMA: Multiple assignment separator (,)</li> <li>SEMICOLON: For loop separator (;)</li> <li>NEWLINE: Statement separator</li> <li>EOF: End of file</li> </ul>"},{"location":"language_spec/#module-system","title":"Module System","text":"<ul> <li>Use <code>import modulename</code> to import a module</li> <li>Access module functions with dot notation: <code>module.function()</code></li> <li>Modules must be imported before use</li> <li>Built-in modules: fmt, math, strings, datetime, os, path, file, log, errors, json, assert</li> </ul>"},{"location":"language_spec/#error-handling","title":"Error Handling","text":""},{"location":"language_spec/#go-style-error-handling-system","title":"Go-Style Error Handling System","text":"<p>Harneet implements a comprehensive Go-style error handling system that emphasizes explicit error checking and prevents silent failures.</p>"},{"location":"language_spec/#core-principles","title":"Core Principles","text":"<ol> <li>No Silent Failures: All functions that can fail return an error value</li> <li>Explicit Error Checking: Errors must be explicitly checked using <code>if err != None</code> pattern</li> <li>Multiple Return Values: Functions return <code>(result, error)</code> tuples</li> <li>Error Propagation: Errors bubble up through the call stack unless handled</li> </ol>"},{"location":"language_spec/#syntax","title":"Syntax","text":""},{"location":"language_spec/#multiple-return-values","title":"Multiple Return Values","text":"<pre><code>var result, err = strings.ToInt(\"123\")\nvar content, err = file.Read(\"config.txt\")  // Future feature\nvar x, y, err = someFunction()\n</code></pre>"},{"location":"language_spec/#error-checking-pattern","title":"Error Checking Pattern","text":"<pre><code>var value, err = riskyFunction()\nif err != None {\n    fmt.Println(\"Error occurred:\", err)\n    return err  // Propagate error up\n}\n// Safe to use value here\nfmt.Println(\"Success:\", value)\n</code></pre>"},{"location":"language_spec/#built-in-error-types","title":"Built-in Error Types","text":"<ul> <li>None: Represents no error (similar to Go's nil)</li> <li>Error Values: First-class error objects with descriptive messages</li> </ul>"},{"location":"language_spec/#standard-library-error-handling","title":"Standard Library Error Handling","text":"<p>All standard library functions return errors:</p> <pre><code>// String conversion with error handling\nvar num, err = strings.ToInt(\"invalid\")\nif err != None {\n    fmt.Println(\"Conversion failed:\", err)\n    // Handle error appropriately\n}\n\n// Math operations with error checking\nvar result, err = math.Pow(2, 64)  // May overflow\nif err != None {\n    fmt.Println(\"Math error:\", err)\n}\n</code></pre>"},{"location":"language_spec/#error-categories","title":"Error Categories","text":"<ul> <li>TypeError: Type conversion or mismatch errors</li> <li>ValueError: Invalid values (division by zero, invalid conversions)</li> <li>RangeError: Values outside acceptable ranges</li> <li>ArithmeticError: Mathematical operation errors</li> </ul>"},{"location":"language_spec/#stack-trace-system","title":"Stack Trace System","text":"<p>Harneet provides comprehensive stack trace information for all runtime errors, making debugging fast and efficient.</p>"},{"location":"language_spec/#features","title":"Features","text":"<ul> <li>Precise Location: Exact file name, line number, and column position</li> <li>Call Hierarchy: Complete function call stack showing execution path</li> <li>Error Context: Clear error messages with full debugging information</li> <li>Multi-level Traces: Nested function calls show complete call chain</li> </ul>"},{"location":"language_spec/#stack-trace-format","title":"Stack Trace Format","text":"<p>When an error occurs, Harneet displays detailed debugging information:</p> <pre><code>ERROR: division by zero\nStack trace:\n  at &lt;program&gt; (examples/myfile.ha:5:22)\n  at math.Max (examples/myfile.ha:5:33)\n</code></pre>"},{"location":"language_spec/#stack-trace-components","title":"Stack Trace Components","text":"<p>Each stack frame includes: - Function Name: <code>&lt;program&gt;</code> for top-level code, <code>module.function</code> for library calls - File Location: Complete file path relative to execution directory - Position: Exact <code>line:column</code> where error occurred or call was made</p>"},{"location":"language_spec/#error-types-with-stack-traces","title":"Error Types with Stack Traces","text":""},{"location":"language_spec/#arithmetic-errors","title":"Arithmetic Errors","text":"<pre><code>var result = 10 / 0  // Division by zero\n// Output:\n// ERROR: division by zero\n// Stack trace:\n//   at &lt;program&gt; (myfile.ha:1:15)\n</code></pre>"},{"location":"language_spec/#identifier-errors","title":"Identifier Errors","text":"<pre><code>var x = undefinedVariable  // Variable not found\n// Output:\n// ERROR: identifier not found: undefinedVariable\n// Stack trace:\n//   at &lt;program&gt; (myfile.ha:1:8)\n</code></pre>"},{"location":"language_spec/#function-call-errors","title":"Function Call Errors","text":"<pre><code>import math\nvar result = math.Max(42, 10 / 0)  // Error in nested call\n// Output:\n// ERROR: division by zero\n// Stack trace:\n//   at &lt;program&gt; (myfile.ha:2:22)\n//   at math.Max (myfile.ha:2:33)\n</code></pre>"},{"location":"language_spec/#type-conversion-errors","title":"Type Conversion Errors","text":"<pre><code>import strings\nvar num, err = strings.ToInt(\"not_a_number\")\nif err != None {\n    // Error is handled gracefully with descriptive message\n    fmt.Println(\"Error:\", err)\n}\n</code></pre>"},{"location":"language_spec/#parser-errors","title":"Parser Errors","text":"<pre><code>var x = 42 +   // Incomplete expression (syntax error)\n// Output:\n// Woops! Sincere apologies, but we ran into some errors while running the program!\n// Stack trace:\n//  parser errors:\n//    no prefix parse function for DIVIDE found\n//    no prefix parse function for ERROR_TYPE found\n//    no prefix parse function for ILLEGAL found\n</code></pre>"},{"location":"language_spec/#benefits","title":"Benefits","text":"<ul> <li>Immediate Location: Know exactly where errors occur</li> <li>Call Context: Understand how execution reached the error</li> <li>File Information: No guessing which file contains the problem</li> <li>Debugging Speed: Quick navigation to problem areas</li> </ul>"},{"location":"language_spec/#control-flow-system","title":"Control Flow System","text":"<p>Harneet provides comprehensive control flow constructs for conditional execution and multi-way branching.</p>"},{"location":"language_spec/#if-else-statements","title":"If-Else Statements","text":""},{"location":"language_spec/#basic-if-else","title":"Basic If-Else","text":"<pre><code>x := 15\nif x &gt; 10 {\n    fmt.Println(\"Greater than 10\")\n} else {\n    fmt.Println(\"10 or less\")\n}\n</code></pre>"},{"location":"language_spec/#else-if-chaining","title":"Else-If Chaining","text":"<pre><code>score := 85\nif score &gt;= 90 {\n    fmt.Println(\"Grade: A\")\n} else if score &gt;= 80 {\n    fmt.Println(\"Grade: B\") \n} else if score &gt;= 70 {\n    fmt.Println(\"Grade: C\")\n} else if score &gt;= 60 {\n    fmt.Println(\"Grade: D\")\n} else {\n    fmt.Println(\"Grade: F\")\n}\n</code></pre>"},{"location":"language_spec/#switch-statements","title":"Switch Statements","text":""},{"location":"language_spec/#integer-switch","title":"Integer Switch","text":"<pre><code>day := 3\nswitch day {\ncase 1 {\n    fmt.Println(\"Monday\")\n}\ncase 2 {\n    fmt.Println(\"Tuesday\")\n}\ncase 3 {\n    fmt.Println(\"Wednesday\")\n}\ndefault {\n    fmt.Println(\"Other day\")\n}\n}\n</code></pre>"},{"location":"language_spec/#string-switch","title":"String Switch","text":"<pre><code>name := \"Alice\"\nswitch name {\ncase \"Bob\" {\n    fmt.Println(\"Hello Bob!\")\n}\ncase \"Alice\" {\n    fmt.Println(\"Hello Alice!\")\n}\ncase \"Charlie\" {\n    fmt.Println(\"Hello Charlie!\")\n}\ndefault {\n    fmt.Println(\"Hello stranger!\")\n}\n}\n</code></pre>"},{"location":"language_spec/#multi-value-cases","title":"Multi-Value Cases","text":"<pre><code>day := 6\nswitch day {\ncase 1 {\n    fmt.Println(\"Monday\")\n}\ncase 2, 3 {\n    fmt.Println(\"Tuesday or Wednesday\")\n}\ncase 4, 5 {\n    fmt.Println(\"Thursday or Friday\")\n}\ncase 6, 7 {\n    fmt.Println(\"Weekend\")\n}\ndefault {\n    fmt.Println(\"Invalid day\")\n}\n}\n</code></pre>"},{"location":"language_spec/#control-flow-rules","title":"Control Flow Rules","text":"<ol> <li>If Conditions: Must evaluate to a truthy or falsy value</li> <li>Case Matching: Exact value equality (===) is used for case comparison</li> <li>Type Consistency: All cases in a switch must use the same data type</li> <li>Default Case: Optional catch-all for unmatched values</li> <li>Multi-Value Cases: Use comma-separated values: <code>case 1, 2, 3 { }</code></li> <li>No Fall-through: Each case block executes independently (like Go, unlike C)</li> </ol>"},{"location":"language_spec/#supported-types-in-switch","title":"Supported Types in Switch","text":"<ul> <li>Integers: <code>case 1, 2, 3 { ... }</code></li> <li>Strings: <code>case \"hello\", \"world\" { ... }</code></li> <li>Mixed types not supported: Each switch statement must use consistent types</li> </ul>"},{"location":"language_spec/#language-evolution","title":"Language Evolution","text":""},{"location":"language_spec/#implemented-features-production-ready","title":"\u2705 Implemented Features (Production Ready)","text":"<p>Core Language Features: - Complete Control Flow System: If-else with chaining, switch with multi-value cases, for loops (traditional and while-style) - User-Defined Functions: Custom function definitions, multiple return values, recursion, closures, nested functions - Arrow Functions: ES6-style syntax with expression and block bodies - Advanced Type System: Comprehensive static type checking, type inference, 12+ numeric types, explicit type declarations - Multiple Variable Assignment: Support for both function tuple returns and multiple expressions with explicit types</p> <p>Data Types &amp; Collections: - Arrays: Dynamic arrays with 14+ built-in methods (length, contains, push, pop, sort, etc.) - Comprehensive Type Support: All integer types (int8-64, uint8-64), floating-point (float32/64), strings with Unicode, booleans - Zero Values: Automatic initialization of variables to appropriate zero values (0 for numbers, \"\" for strings, false for bools) - Unicode Support: Full UTF-8 support with international characters, emojis, and all language scripts - Type Safety: Static analysis prevents runtime type errors with intelligent inference - Blank Identifier: <code>_</code> support for discarding unwanted values in multiple assignment</p> <p>Standard Library (12 Modules): - File I/O: Complete file operations (read, write, append, copy, size) via <code>file</code> module - JSON Processing: RFC 8259 compliant JSON marshaling/unmarshaling with validation - Array Operations: Comprehensive array manipulation with <code>arrays</code> module - System Integration: OS interface, environment variables, filesystem operations - Date/Time: Advanced datetime with timezone support, timers, tickers, and complete cron scheduling system - Logging: Structured logging system with multiple levels - Error Handling: Go-style error interface with explicit checking and propagation</p> <p>Development Tools: - REPL Support: Interactive development environment - Debug Mode: Comprehensive logging and debugging capabilities - Stack Traces: Detailed error reporting with precise source locations - Import Analysis: Unused import detection and module aliasing - Runtime Assertions: Development-time checks with <code>assert</code> module</p>"},{"location":"language_spec/#future-enhancements-not-essential-for-production-use","title":"\ud83d\udea7 Future Enhancements (Not Essential for Production Use)","text":"<p>Advanced Language Features: - Named Return Values: Go-style named function returns - Variadic Functions: Functions with variable argument lists - Generic Types: Type parameterization for reusable code - Defer Statements: Resource cleanup and deferred execution - Custom Error Types: User-defined error types and error wrapping - Map/Dictionary Type: Key-value data structures - Struct Types: Custom composite data types</p> <p>Extended Standard Library: - HTTP Module: Web server and client functionality - Database Module: SQL database connectivity - Crypto Module: Cryptographic functions and hashing - Regex Module: Regular expression support - Threading Module: Concurrent programming primitives</p>"},{"location":"language_spec/#summary","title":"Summary","text":"<p>Harneet is a powerful, modern interpreted language that successfully combines:</p> <ul> <li>Go's Clean Syntax: Simple, readable code structure with curly braces</li> <li>Python's Ergonomics: Intuitive logical operators (<code>and</code>, <code>or</code>, <code>not</code>) and user-friendly design</li> <li>Modern Type Safety: Comprehensive static type checking with intelligent inference</li> <li>Rich Standard Library: 12 comprehensive built-in modules covering all common programming needs</li> <li>Unicode First: Native support for international text, emojis, and all character sets</li> <li>Developer Friendly: Excellent error messages, REPL support, and advanced debugging tools</li> </ul>"},{"location":"language_spec/#ideal-use-cases","title":"Ideal Use Cases","text":"<ul> <li>System Scripting: File operations, OS interaction, and automation tasks</li> <li>Data Processing: JSON handling, array manipulation, and string processing</li> <li>Web Development: HTTP operations and API development (with extensible module system)</li> <li>Educational Programming: Clean syntax makes it perfect for learning programming concepts</li> <li>Rapid Prototyping: Quick iteration with comprehensive built-in functionality</li> <li>International Applications: Full Unicode support for global software development</li> </ul> <p>With its comprehensive feature set, robust error handling, and thoughtful language design, Harneet provides a productive and enjoyable programming environment for developers at all levels.</p>"},{"location":"type_system_safety/","title":"Type System &amp; Safety","text":"<p>Harneet features a robust and comprehensive type system designed to ensure code correctness and prevent runtime errors through static analysis.</p>"},{"location":"type_system_safety/#comprehensive-type-checking","title":"Comprehensive Type Checking","text":"<ul> <li> <p>Static Type Analysis: Harneet performs complete type checking during the parsing phase, catching type-related errors before runtime.</p> <pre><code>```harneet\n// Example: Type mismatch caught at compile time\nvar num int = \"hello\" // Error: Cannot assign string to int\n```\n</code></pre> </li> <li> <p>Function Parameter Validation: Automatic type checking ensures that function calls provide arguments matching the declared parameter types, with detailed error messages for mismatches.</p> <pre><code>```harneet\nfunction add(a int, b int) int {\n    return a + b\n}\nvar result = add(10, \"hello\") // Error: Argument 'hello' (string) cannot be assigned to parameter 'b' (int)\n```\n</code></pre> </li> <li> <p>Variable Type Declarations: Explicit type annotations (e.g., <code>var x int = 42</code>) allow for compile-time validation, ensuring type consistency.</p> <pre><code>```harneet\nvar age int = 30\n// var age string = \"thirty\" // Error: Cannot re-declare 'age' with a different type\n```\n</code></pre> </li> <li> <p>Return Type Validation: Functions must return values that match their declared return types.</p> <pre><code>```harneet\nfunction getNumber() int {\n    return \"hello\" // Error: Function declared to return int, but returning string\n}\n```\n</code></pre> </li> <li> <p>Array Type Consistency: Arrays can be type-safe (e.g., <code>int[]</code>, <code>string[]</code>, <code>bool[]</code>), with validation of element types.</p> <pre><code>```harneet\nvar numbers = [1, 2, 3] // Inferred as int[]\n// numbers = [1, \"hello\"] // Error: Cannot assign string to int[] array\n```\n</code></pre> </li> <li> <p>Advanced Type Inference: The language features sophisticated type inference for expressions, arrays, and function calls, reducing the need for explicit type declarations.</p> <pre><code>```harneet\nvar inferredNum = 10          // inferred as int\nvar inferredStr = \"Harneet\"   // inferred as string\nvar inferredBool = true       // inferred as bool\n```\n</code></pre> </li> <li> <p>Type Compatibility: Smart type compatibility rules are applied for numeric types and safe conversions.</p> <pre><code>```harneet\nvar intVal int = 10\nvar floatVal float64 = intVal // int can be assigned to float64\n// var anotherInt int = floatVal // Error: float64 cannot be assigned to int without explicit conversion\n```\n</code></pre> </li> <li> <p>Enhanced Error Messages: Detailed error messages provide helpful suggestions and precise locations for type-related issues.</p> <pre><code>```harneet\n// Example of an enhanced error message\n// Calling a function with wrong argument type might produce:\n// Error: Argument 'hello' (string) cannot be assigned to parameter 'b' (int) in function 'add' at line 5, column 12.\n// Suggestion: Ensure argument type matches parameter type.\n```\n</code></pre> </li> <li> <p>Zero Runtime Type Errors: Static analysis aims to prevent type-related errors from occurring at runtime.</p> <pre><code>```harneet\n// Because of static analysis, code like this will not even run:\n// var x int = \"abc\" // Caught at compile time, preventing runtime crash\n```\n</code></pre> </li> <li> <p>Zero Value Type Safety: All declared variables automatically receive appropriate zero values for their respective types, ensuring predictable behavior.</p> <pre><code>```harneet\nvar defaultInt int       // defaultInt is 0\nvar defaultString string // defaultString is \"\"\nvar defaultBool bool     // defaultBool is false\n```\n</code></pre> </li> </ul>"},{"location":"type_system_safety/#development-features","title":"Development Features","text":"<p>The type system is complemented by several development features that aid in debugging and code quality.</p> <ul> <li>REPL Support: The interactive Read-Eval-Print Loop (REPL) provides immediate feedback on type correctness during development.</li> <li>Debug Mode: A comprehensive logging system with a <code>-debug</code> flag helps in tracing type-related issues.</li> <li>Stack Traces: Detailed error traces with source locations provide context for type errors.</li> <li>Import Analysis: The system detects unused and duplicate imports, promoting cleaner code.</li> <li>Error Suggestions: Helpful error messages often include suggestions for fixing type-related problems.</li> </ul>"},{"location":"type_system_safety/#zero-values-system","title":"Zero Values System","text":"<p>Harneet automatically initializes all declared variables to their \"zero value\" if no explicit value is provided. This ensures that variables always have a defined state.</p> <pre><code>// All integer types initialize to 0\nvar intVal int           // 0\nvar int8Val int8         // 0\nvar int16Val int16       // 0\nvar int32Val int32       // 0\nvar int64Val int64       // 0\nvar uintVal uint         // 0\nvar uint8Val uint8       // 0\nvar uint16Val uint16     // 0\nvar uint32Val uint32     // 0\nvar uint64Val uint64     // 0\nvar uintptrVal uintptr   // 0\n\n// Float types initialize to 0.0\nvar float32Val float32   // 0.0\nvar float64Val float64   // 0.0\n\n// String type initializes to empty string\nvar stringVal string     // \"\"\n\n// Boolean type initializes to false\nvar boolVal bool         // false\n\n// Mixed zero value and explicit assignments\nvar zeroInt int          // 0 (zero value)\nvar assignedInt int = 42 // 42 (explicit value)\n</code></pre>"},{"location":"type_system_safety/#multiple-assignment-examples","title":"Multiple Assignment Examples","text":"<p>The type system works seamlessly with multiple assignment, ensuring type safety even when multiple values are returned or assigned.</p> <pre><code>// Function returns (traditional tuple assignment)\nvar result, err = math.Abs(-42)\nvar upper, upperErr = strings.Upper(\"hello\")\n\n// Multiple expressions with explicit types\nvar name string, age int, score float64 = \"Alice\", 25, 98.5\nvar x int, y int, z int = 10, 20, 30\n\n// Mixed explicit and inferred types\nvar first string, second, third int = \"test\", 42, 100\n\n// Short assignment with multiple expressions\na, b, c := \"hello\", 123, true\ncoordinates := 1.0, 2.0, 3.0\n\n// Blank identifier support\nvar value, _ = math.Max(10, 5)  // Discard error\nvar _, important, _ = \"ignore\", \"keep\", \"ignore\"\n</code></pre>"},{"location":"functions/advanced_features/","title":"Advanced Function Features","text":"<p>Harneet functions support several advanced features that make them powerful and flexible.</p>"},{"location":"functions/advanced_features/#multiple-return-values","title":"Multiple Return Values","text":"<p>A function can return multiple values. This is particularly useful for returning a result and an error, which is a common pattern in Harneet.</p> <pre><code>import fmt\n\nfunction divide(a float64, b float64) (float64, string) {\n    if b == 0 {\n        return 0.0, \"division by zero\"\n    }\n    return a / b, \"\"\n}\n\nvar result, err = divide(10, 2)\nif err != \"\" {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 5\n}\n\nvar result2, err2 = divide(10, 0)\nif err2 != \"\" {\n    fmt.Println(\"Error:\", err2) // Output: Error: division by zero\n} else {\n    fmt.Println(\"Result:\", result2)\n}\n</code></pre>"},{"location":"functions/advanced_features/#closures","title":"Closures","text":"<p>Functions in Harneet are closures, which means they can access variables from their enclosing scope.</p> <pre><code>import fmt\n\nfunction outer() {\n    var x = 10\n    function inner() {\n        fmt.Println(x)\n    }\n    return inner\n}\n\nvar closure = outer()\nclosure() // Output: 10\n</code></pre>"},{"location":"functions/advanced_features/#first-class-functions","title":"First-Class Functions","text":"<p>Functions are first-class citizens in Harneet, which means they can be treated like any other value. They can be assigned to variables, passed as arguments to other functions, and returned from functions.</p> <pre><code>import fmt\n\nfunction apply(f function(int) int, value int) int {\n    return f(value)\n}\n\nfunction double(x int) int {\n    return x * 2\n}\n\nvar result = apply(double, 5)\nfmt.Println(result) // Output: 10\n</code></pre>"},{"location":"functions/arrow_functions/","title":"Arrow Functions","text":"<p>Harneet supports ES6-style arrow functions, which provide a more concise syntax for writing functions.</p>"},{"location":"functions/arrow_functions/#syntax","title":"Syntax","text":""},{"location":"functions/arrow_functions/#single-parameter","title":"Single parameter","text":"<p>If there is only one parameter, the parentheses are optional.</p> <pre><code>var double = x =&gt; x * 2\n</code></pre>"},{"location":"functions/arrow_functions/#multiple-parameters","title":"Multiple parameters","text":"<p>If there are multiple parameters, the parentheses are required.</p> <pre><code>var add = (a, b) =&gt; a + b\n</code></pre>"},{"location":"functions/arrow_functions/#block-body","title":"Block body","text":"<p>For a multi-line function body, you can use a block body with an explicit <code>return</code> statement.</p> <pre><code>var complex = (x, y) =&gt; {\n    var result = x + y\n    return result * 2\n}\n</code></pre>"},{"location":"functions/arrow_functions/#examples","title":"Examples","text":"<pre><code>import fmt\n\nvar double = x =&gt; x * 2\nfmt.Println(double(5)) // Output: 10\n\nvar add = (a, b) =&gt; a + b\nfmt.Println(add(5, 10)) // Output: 15\n\nvar complex = (x, y) =&gt; {\n    var result = x + y\n    return result * 2\n}\nfmt.Println(complex(5, 10)) // Output: 30\n</code></pre>"},{"location":"functions/introduction/","title":"Introduction to Functions","text":"<p>Functions are reusable blocks of code that perform a specific task. They are a fundamental building block of Harneet programs.</p>"},{"location":"functions/introduction/#declaration-syntax","title":"Declaration Syntax","text":"<p>The basic syntax for declaring a function is as follows:</p> <pre><code>function functionName(param1 type1, param2 type2) returnType {\n    // function body\n    return value\n}\n</code></pre> <ul> <li><code>function</code>: The keyword to declare a function.</li> <li><code>functionName</code>: The name of the function.</li> <li><code>(param1 type1, param2 type2)</code>: The list of parameters with their types.</li> <li><code>returnType</code>: The type of the value returned by the function.</li> <li><code>{ ... }</code>: The body of the function containing the code to be executed.</li> <li><code>return</code>: The keyword to return a value from the function.</li> </ul>"},{"location":"functions/introduction/#examples","title":"Examples","text":""},{"location":"functions/introduction/#function-with-a-single-return-value","title":"Function with a single return value","text":"<pre><code>import fmt\n\nfunction square(x int) int {\n    return x * x\n}\n\nvar result = square(5)\nfmt.Println(result) // Output: 25\n</code></pre>"},{"location":"functions/introduction/#function-with-no-parameters","title":"Function with no parameters","text":"<pre><code>import fmt\n\nfunction getAnswer() int {\n    return 42\n}\n\nvar answer = getAnswer()\nfmt.Println(answer) // Output: 42\n</code></pre>"},{"location":"functions/introduction/#function-with-no-return-value","title":"Function with no return value","text":"<pre><code>import fmt\n\nfunction printMessage() {\n    fmt.Println(\"Hello, Harneet!\")\n}\n\nprintMessage() // Output: Hello, Harneet!\n</code></pre>"},{"location":"general/arrays/","title":"Arrays","text":"<p>Arrays are ordered collections of elements. They are a versatile data structure for storing lists of values.</p>"},{"location":"general/arrays/#array-literals","title":"Array Literals","text":"<p>You can create an array using an array literal:</p> <pre><code>var numbers = [1, 2, 3, 4, 5]\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre>"},{"location":"general/arrays/#mixed-types","title":"Mixed Types","text":"<p>Arrays in Harneet can hold elements of different types.</p> <pre><code>var mixed = [1, \"hello\", 3.14, true]\n</code></pre>"},{"location":"general/arrays/#nested-arrays","title":"Nested Arrays","text":"<p>You can create nested arrays (arrays of arrays).</p> <pre><code>var matrix = [[1, 2], [3, 4]]\n</code></pre>"},{"location":"general/arrays/#array-operations","title":"Array Operations","text":"<p>For a comprehensive list of functions to manipulate arrays, see the <code>arrays</code> module documentation.</p>"},{"location":"general/block_structure/","title":"Block Structure","text":"<p>Harneet uses curly braces <code>{}</code> to define blocks of code. These blocks group statements together.</p>"},{"location":"general/block_structure/#blocks","title":"Blocks","text":"<ul> <li>Purpose: Blocks are used to group statements, typically associated with control flow statements (like <code>if</code>, <code>for</code>, <code>switch</code>) or function definitions.</li> <li>Syntax: Statements within a block are enclosed in curly braces <code>{}</code>.</li> </ul> <pre><code>if condition {\n    // statements inside the block\n    fmt.Println(\"Condition is true\")\n}\n</code></pre>"},{"location":"general/block_structure/#statement-terminators","title":"Statement Terminators","text":"<p>Harneet supports both newlines and semicolons as statement terminators. You can use either, or mix them.</p> <ul> <li>Newline: A new line implicitly terminates a statement.</li> <li>Semicolon: A semicolon <code>;</code> explicitly terminates a statement.</li> </ul> <pre><code>// Using newlines\nvar x = 10\nvar y = 20\n\n// Using semicolons\nvar a = 1; var b = 2;\n</code></pre>"},{"location":"general/block_structure/#indentation","title":"Indentation","text":"<p>Indentation is not syntactically significant in Harneet (unlike Python), but it is highly recommended for readability and maintaining consistent code style.</p>"},{"location":"general/comments/","title":"Comments","text":"<p>Comments are used to add explanatory notes to your code. They are ignored by the interpreter.</p>"},{"location":"general/comments/#line-comments","title":"Line Comments","text":"<p>Line comments start with <code>//</code>. Everything from <code>//</code> to the end of the line is a comment.</p> <pre><code>// This is a line comment\nvar x = 42 // This is also a line comment\n</code></pre>"},{"location":"general/comments/#block-comments","title":"Block Comments","text":"<p>Block comments start with <code>/*</code> and end with <code>*/</code>. They can span multiple lines.</p> <pre><code>/*\nThis is a block comment.\nIt can span multiple lines.\n*/\nvar y = 10\n</code></pre>"},{"location":"general/control_flow/","title":"Control Flow Structures","text":"<p>Harneet provides a variety of control flow structures to direct the execution of your program.</p>"},{"location":"general/control_flow/#if-else-statements","title":"If-Else Statements","text":"<p>If-else statements allow you to execute code conditionally.</p> <pre><code>if score &gt;= 90 {\n    fmt.Println(\"Grade: A\")\n} else if score &gt;= 80 {\n    fmt.Println(\"Grade: B\")\n} else {\n    fmt.Println(\"Grade: F\")\n}\n</code></pre>"},{"location":"general/control_flow/#switch-statements","title":"Switch Statements","text":"<p>Switch statements provide a way to execute different code blocks based on the value of an expression.</p> <pre><code>switch day {\ncase 1:\n    fmt.Println(\"Monday\")\ncase 2, 3:\n    fmt.Println(\"Tuesday or Wednesday\")\ndefault:\n    fmt.Println(\"Other day\")\n}\n</code></pre>"},{"location":"general/control_flow/#for-loops","title":"For Loops","text":"<p>For loops are used to execute a block of code repeatedly.</p>"},{"location":"general/control_flow/#c-style-for-loop","title":"C-style For Loop","text":"<pre><code>for i := 0; i &lt; 10; i = i + 1 {\n    fmt.Println(i)\n}\n</code></pre>"},{"location":"general/control_flow/#while-style-for-loop","title":"While-style For Loop","text":"<pre><code>for condition {\n    // code executes while condition is true\n}\n</code></pre>"},{"location":"general/data_types/","title":"Data Types","text":"<p>Harneet supports a variety of built-in data types to represent different kinds of values.</p>"},{"location":"general/data_types/#integers","title":"Integers","text":"<p>Integers are whole numbers, positive or negative. Harneet provides various integer types to accommodate different ranges and memory requirements.</p> <ul> <li>Literals: <code>42</code>, <code>-17</code>, <code>0x1A</code> (hexadecimal), <code>0b1010</code> (binary)</li> <li>Types: <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> (signed integers)</li> <li>Unsigned Types: <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code> (unsigned integers)</li> <li>Automatic Type Inference: Harneet can automatically infer the most appropriate integer type based on the value.</li> <li>Explicit Declarations: You can explicitly declare the integer type.</li> </ul>"},{"location":"general/data_types/#floating-point-numbers","title":"Floating-point Numbers","text":"<p>Floating-point numbers represent real numbers with decimal points.</p> <ul> <li>Literals: <code>3.14</code>, <code>-2.71</code>, <code>1.23e-4</code> (scientific notation)</li> <li>Types: <code>float32</code>, <code>float64</code> (IEEE-754 compliant)</li> <li>Precision: Harneet ensures precision preservation in all floating-point operations.</li> </ul>"},{"location":"general/data_types/#strings","title":"Strings","text":"<p>Strings are sequences of characters. Harneet has robust support for Unicode.</p> <ul> <li>Literals: <code>\"Hello World\"</code>, <code>\"Unicode: \u4f60\u597d\u4e16\u754c \ud83c\udf0d\"</code>, <code>\"Multi\\nLine\"</code></li> <li>Encoding: UTF-8 native support for full Unicode handling.</li> <li>Escape Sequences: <code>\\n</code> (newline), <code>\\t</code> (tab), <code>\\\"</code> (double quote), <code>\\\\</code> (backslash)</li> <li>Concatenation: Use the <code>+</code> operator to join strings.</li> </ul>"},{"location":"general/data_types/#booleans","title":"Booleans","text":"<p>Booleans represent truth values, either <code>true</code> or <code>false</code>.</p> <ul> <li>Literals: <code>true</code>, <code>false</code></li> <li>Logical Operations: <code>and</code>, <code>or</code>, <code>not</code> (Python-style with short-circuit evaluation)</li> <li>No Implicit Conversion: Booleans are not implicitly converted from other types.</li> </ul>"},{"location":"general/data_types/#arrays","title":"Arrays","text":"<p>Arrays are ordered, mutable collections of elements.</p> <ul> <li>Literals: <code>[1, 2, 3]</code>, <code>[\"a\", \"b\", \"c\"]</code>, <code>[[1, 2], [3, 4]]</code></li> <li>Dynamic Resizing: Arrays can grow or shrink dynamically.</li> <li>Mixed Type Support: Arrays can contain elements of different data types.</li> <li>Nested Arrays: Arrays can be nested to arbitrary depths.</li> <li>Indexing: Zero-based indexing with bounds checking.</li> <li>Module: For comprehensive array operations, refer to the <code>arrays</code> module in the Standard Library.</li> </ul>"},{"location":"general/data_types/#none","title":"None","text":"<p><code>None</code> is a special value that represents the absence of a value, similar to <code>nil</code> in Go or <code>None</code> in Python.</p> <ul> <li>Usage: Used extensively in error handling to indicate no error.</li> <li>Explicit Checking: Requires explicit checking (e.g., <code>if err != None</code>).</li> </ul>"},{"location":"general/import_system/","title":"Import System","text":"<p>The <code>import</code> statement is used to bring modules into the current scope, allowing you to use their functions.</p>"},{"location":"general/import_system/#single-import","title":"Single Import","text":"<p>You can import a single module on one line.</p> <pre><code>import fmt\n</code></pre>"},{"location":"general/import_system/#multiple-imports","title":"Multiple Imports","text":"<p>You can import multiple modules on a single line, separated by commas.</p> <pre><code>import fmt, math, strings\n</code></pre>"},{"location":"general/import_system/#import-aliases","title":"Import Aliases","text":"<p>You can create an alias for an imported module using the <code>as</code> keyword. This is useful to avoid name collisions or to use a shorter name.</p> <pre><code>import fmt as f\n\nf.Println(\"Hello, World!\")\n</code></pre>"},{"location":"general/import_system/#import-validation","title":"Import Validation","text":"<p>The interpreter will automatically detect and report errors for duplicate imports.</p> <p>!!! warning \"Unused Imports\"     For unused imports, the interpreter will issue a warning. This helps to keep the code clean and avoid unnecessary imports.</p>"},{"location":"general/keywords_identifiers/","title":"Keywords and Identifiers","text":""},{"location":"general/keywords_identifiers/#keywords","title":"Keywords","text":"<p>Keywords are reserved words in Harneet that have special meaning and cannot be used as identifiers (e.g., variable names, function names).</p>"},{"location":"general/keywords_identifiers/#reserved-keywords","title":"Reserved Keywords","text":"<ul> <li><code>var</code>: Used for variable declaration.</li> <li><code>function</code>: Used for function declaration.</li> <li><code>if</code>, <code>else</code>: Used for conditional statements.</li> <li><code>for</code>: Used for loops.</li> <li><code>switch</code>, <code>case</code>, <code>default</code>: Used for switch statements.</li> <li><code>import</code>: Used to import modules.</li> <li><code>return</code>: Used to return values from functions.</li> <li><code>and</code>, <code>or</code>, <code>not</code>: Logical operators.</li> <li><code>true</code>, <code>false</code>: Boolean literals.</li> <li><code>None</code>: Represents the absence of a value.</li> </ul>"},{"location":"general/keywords_identifiers/#type-keywords","title":"Type Keywords","text":"<p>These keywords are used to specify data types.</p> <ul> <li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>: Signed integer types.</li> <li><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code>: Unsigned integer types.</li> <li><code>float32</code>, <code>float64</code>: Floating-point types.</li> <li><code>string</code>: String type.</li> <li><code>bool</code>: Boolean type.</li> </ul>"},{"location":"general/keywords_identifiers/#identifiers","title":"Identifiers","text":"<p>Identifiers are names given to variables, functions, modules, and other program entities.</p> <ul> <li>Rules:<ul> <li>Must start with a letter (a-z, A-Z) or an underscore (<code>_</code>).</li> <li>Can contain letters, numbers (0-9), and underscores.</li> <li>Case-sensitive (e.g., <code>myVar</code> and <code>myvar</code> are different).</li> </ul> </li> <li>Conventions: Follow consistent naming conventions for readability.</li> </ul>"},{"location":"general/operators_and_expressions/","title":"Operators and Expressions","text":"<p>Harneet supports a variety of operators for performing arithmetic, comparison, and logical operations.</p>"},{"location":"general/operators_and_expressions/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li><code>+</code>: Addition</li> <li><code>-</code>: Subtraction</li> <li><code>*</code>: Multiplication</li> <li><code>/</code>: Division</li> <li><code>%</code>: Modulo (remainder)</li> </ul>"},{"location":"general/operators_and_expressions/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>==</code>: Equal to</li> <li><code>!=</code>: Not equal to</li> <li><code>&lt;</code>: Less than</li> <li><code>&gt;</code>: Greater than</li> <li><code>&lt;=</code>: Less than or equal to</li> <li><code>&gt;=</code>: Greater than or equal to</li> </ul>"},{"location":"general/operators_and_expressions/#logical-operators","title":"Logical Operators","text":"<ul> <li><code>and</code>: Logical AND (short-circuiting)</li> <li><code>or</code>: Logical OR (short-circuiting)</li> <li><code>not</code>: Logical NOT</li> </ul>"},{"location":"general/operators_and_expressions/#assignment-operators","title":"Assignment Operators","text":"<ul> <li><code>=</code>: Assignment</li> <li><code>:=</code>: Short declaration and assignment</li> </ul>"},{"location":"general/operators_and_expressions/#string-concatenation","title":"String Concatenation","text":"<p>The <code>+</code> operator can be used to concatenate strings.</p> <pre><code>var greeting = \"Hello, \" + \"World!\"\n</code></pre>"},{"location":"general/operators_and_expressions/#precedence","title":"Precedence","text":"<p>Harneet follows standard mathematical operator precedence. You can use parentheses <code>()</code> to group expressions and control the order of evaluation.</p>"},{"location":"general/scoping_variable_management/","title":"Scoping and Variable Management","text":"<p>Scoping rules determine where variables are accessible in your program. Harneet uses lexical scoping, meaning the scope of a variable is determined by its position in the source code.</p>"},{"location":"general/scoping_variable_management/#global-scope","title":"Global Scope","text":"<p>Variables declared outside of any function or block have global scope and are accessible from anywhere in the program.</p> <pre><code>var global = \"accessible everywhere\"\n\nfunction printGlobal() {\n    fmt.Println(global)\n}\n\nprintGlobal() // Output: accessible everywhere\n</code></pre>"},{"location":"general/scoping_variable_management/#local-scope-function-scope","title":"Local Scope (Function Scope)","text":"<p>Variables declared inside a function have local scope and are only accessible within that function.</p> <pre><code>function example() {\n    var local = \"only in function\"\n    fmt.Println(local)\n}\n\nexample() // Output: only in function\n// fmt.Println(local) // Error: local is not defined\n</code></pre>"},{"location":"general/scoping_variable_management/#block-scope","title":"Block Scope","text":"<p>Variables declared inside a block (e.g., <code>if</code> statements, <code>for</code> loops) have block scope and are only accessible within that block.</p> <pre><code>if true {\n    var blockScope = \"only in this block\"\n    fmt.Println(blockScope) // Output: only in this block\n}\n// fmt.Println(blockScope) // Error: blockScope is not defined\n</code></pre>"},{"location":"general/scoping_variable_management/#accessing-outer-scope-variables","title":"Accessing Outer Scope Variables","text":"<p>Inner scopes can access variables from their outer (enclosing) scopes.</p> <pre><code>var outerVar = \"I am from outer scope\"\n\nfunction outer() {\n    var innerVar = \"I am from inner scope\"\n    function nested() {\n        fmt.Println(outerVar) // Access outerVar from outer scope\n        fmt.Println(innerVar) // Access innerVar from inner scope\n    }\n    nested()\n}\n\nouter()\n</code></pre>"},{"location":"general/scoping_variable_management/#variable-shadowing","title":"Variable Shadowing","text":"<p>If a variable in an inner scope has the same name as a variable in an outer scope, the inner variable \"shadows\" the outer one within its scope.</p> <pre><code>var x = 10\n\nfunction shadowExample() {\n    var x = 20 // This 'x' shadows the global 'x'\n    fmt.Println(x) // Output: 20\n}\n\nshadowExample()\nfmt.Println(x) // Output: 10 (global 'x' is unchanged)\n</code></pre>"},{"location":"general/unicode_support/","title":"Unicode Support","text":"<p>Harneet has first-class support for Unicode, allowing you to work with international characters and emojis seamlessly.</p>"},{"location":"general/unicode_support/#utf-8-encoding","title":"UTF-8 Encoding","text":"<p>All strings in Harneet are UTF-8 encoded. This means you can use any Unicode character in your strings, comments, and identifiers.</p>"},{"location":"general/unicode_support/#examples","title":"Examples","text":""},{"location":"general/unicode_support/#unicode-in-strings","title":"Unicode in Strings","text":"<pre><code>import fmt\n\nvar greeting = \"Hello, \u4e16\u754c \ud83c\udf0d\"\nfmt.Println(greeting)\n</code></pre>"},{"location":"general/unicode_support/#unicode-in-identifiers","title":"Unicode in Identifiers","text":"<pre><code>var \u4f60\u597d = \"Hello\"\nfmt.Println(\u4f60\u597d)\n</code></pre>"},{"location":"general/variable_declaration/","title":"Variable Declaration &amp; Assignment","text":"<p>Variables are used to store data in Harneet. Harneet provides flexible ways to declare and assign values to variables.</p>"},{"location":"general/variable_declaration/#explicit-type-declaration","title":"Explicit Type Declaration","text":"<p>You can explicitly declare the type of a variable when you declare it.</p> <pre><code>var x int = 42\nvar name string = \"Hello\"\n</code></pre>"},{"location":"general/variable_declaration/#type-inference","title":"Type Inference","text":"<p>Harneet can infer the type of a variable based on the value assigned to it.</p> <pre><code>var x = 42        // x is inferred as int\nvar name = \"Hello\"  // name is inferred as string\n</code></pre>"},{"location":"general/variable_declaration/#short-declaration","title":"Short Declaration","text":"<p>The <code>:=</code> operator provides a shorthand for declaring and assigning a value to a variable. The type is automatically inferred.</p> <pre><code>x := 42\nmessage := \"Hi there\"\n</code></pre>"},{"location":"general/variable_declaration/#assignment","title":"Assignment","text":"<p>You can assign a new value to an existing variable using the <code>=</code> operator.</p> <pre><code>var count = 10\ncount = 20 // Assign a new value\n</code></pre>"},{"location":"general/variable_declaration/#zero-value-initialization","title":"Zero Value Initialization","text":"<p>When a variable is declared without an explicit initial value, it is automatically initialized to its \"zero value\".</p> <ul> <li>Integer Types: <code>0</code></li> <li>Float Types: <code>0.0</code></li> <li>String Type: <code>\"\"</code> (empty string)</li> <li>Boolean Type: <code>false</code></li> </ul> <pre><code>var intVal int       // intVal is 0\nvar floatVal float64 // floatVal is 0.0\nvar strVal string    // strVal is \"\"\nvar boolVal bool     // boolVal is false\n</code></pre>"},{"location":"general/variable_declaration/#multiple-assignment","title":"Multiple Assignment","text":"<p>Harneet supports assigning multiple values to multiple variables in a single statement. This is particularly useful for functions that return multiple values.</p>"},{"location":"general/variable_declaration/#function-returns","title":"Function Returns","text":"<pre><code>import math\n\nfunction getAbs(num int) (int, string) {\n    if num &lt; 0 {\n        return -num, \"\"\n    }\n    return num, \"\"\n}\n\nvar result, err = getAbs(-42)\nif err != \"\" {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Absolute value:\", result) // Output: Absolute value: 42\n}\n</code></pre>"},{"location":"general/variable_declaration/#multiple-expressions","title":"Multiple Expressions","text":"<pre><code>var name string, age int, score float64 = \"Alice\", 25, 98.5\nvar x, y, z int = 10, 20, 30\n</code></pre>"},{"location":"general/variable_declaration/#short-multiple-assignment","title":"Short Multiple Assignment","text":"<pre><code>a, b, c := \"hello\", 123, true\n</code></pre>"},{"location":"general/variable_declaration/#blank-identifier","title":"Blank Identifier","text":"<p>The blank identifier <code>_</code> can be used to discard unwanted values in multiple assignment operations.</p> <pre><code>import math\n\nvar value, _ = math.Max(10, 5) // Discard the error return value\n</code></pre>"},{"location":"stdlib/arrays/","title":"<code>arrays</code> Module","text":"<p>The <code>arrays</code> module provides a comprehensive set of functions for array manipulation.</p>"},{"location":"stdlib/arrays/#functions","title":"Functions","text":""},{"location":"stdlib/arrays/#lengtharray","title":"<code>length(array)</code>","text":"<p>Returns the number of elements in an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(integer, error)</code>: The length of the array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar len, _ = arrays.length(a)\nfmt.Println(len) // Output: 3\n</code></pre>"},{"location":"stdlib/arrays/#containsarray-value","title":"<code>contains(array, value)</code>","text":"<p>Checks if a value exists in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>value</code>: The value to search for.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the value is found, <code>false</code> otherwise.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar found, _ = arrays.contains(a, 2)\nfmt.Println(found) // Output: true\n</code></pre>"},{"location":"stdlib/arrays/#indexarray-value","title":"<code>index(array, value)</code>","text":"<p>Returns the index of the first occurrence of a value in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>value</code>: The value to search for.</p> <p>Returns: - <code>(integer, error)</code>: The index of the value, or -1 if not found.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3, 2]\nvar i, _ = arrays.index(a, 2)\nfmt.Println(i) // Output: 1\n</code></pre>"},{"location":"stdlib/arrays/#pusharray-value","title":"<code>push(array, value)</code>","text":"<p>Adds one or more elements to the end of an array and returns the new array.</p> <p>Parameters: - <code>array</code>: An array. - <code>value...</code>: The element(s) to add.</p> <p>Returns: - <code>(array, error)</code>: The new array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.push(a, 4, 5)\nfmt.Println(b) // Output: [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"stdlib/arrays/#poparray","title":"<code>pop(array)</code>","text":"<p>Removes the last element from an array and returns that element.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(any, error)</code>: The removed element.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar last, _ = arrays.pop(a)\nfmt.Println(last) // Output: 3\nfmt.Println(a) // Output: [1, 2]\n</code></pre>"},{"location":"stdlib/arrays/#replacearray-index-value","title":"<code>replace(array, index, value)</code>","text":"<p>Replaces an element at a specific index in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>index</code>: The index of the element to replace. - <code>value</code>: The new value.</p> <p>Returns: - <code>(array, error)</code>: The modified array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.replace(a, 1, 42)\nfmt.Println(b) // Output: [1, 42, 3]\n</code></pre>"},{"location":"stdlib/arrays/#deletearray-index","title":"<code>delete(array, index)</code>","text":"<p>Removes an element at a specific index in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>index</code>: The index of the element to remove.</p> <p>Returns: - <code>(array, error)</code>: The modified array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.delete(a, 1)\nfmt.Println(b) // Output: [1, 3]\n</code></pre>"},{"location":"stdlib/arrays/#copyarray","title":"<code>copy(array)</code>","text":"<p>Creates a shallow copy of an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(array, error)</code>: A new array that is a copy of the original.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.copy(a)\nfmt.Println(b) // Output: [1, 2, 3]\n</code></pre>"},{"location":"stdlib/arrays/#cleararray","title":"<code>clear(array)</code>","text":"<p>Removes all elements from an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(array, error)</code>: The empty array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.clear(a)\nfmt.Println(b) // Output: []\n</code></pre>"},{"location":"stdlib/arrays/#equalarray1-array2","title":"<code>equal(array1, array2)</code>","text":"<p>Compares two arrays for equality.</p> <p>Parameters: - <code>array1</code>: The first array. - <code>array2</code>: The second array.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the arrays are equal, <code>false</code> otherwise.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b = [1, 2, 3]\nvar c = [4, 5, 6]\n\nvar eq1, _ = arrays.equal(a, b)\nfmt.Println(eq1) // Output: true\n\nvar eq2, _ = arrays.equal(a, c)\nfmt.Println(eq2) // Output: false\n</code></pre>"},{"location":"stdlib/arrays/#sortarray","title":"<code>sort(array)</code>","text":"<p>Sorts the elements of an array in place.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(array, error)</code>: The sorted array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [3, 1, 2]\nvar b, _ = arrays.sort(a)\nfmt.Println(b) // Output: [1, 2, 3]\n</code></pre>"},{"location":"stdlib/arrays/#memoryarray","title":"<code>memory(array)</code>","text":"<p>Returns the memory usage of an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(integer, error)</code>: The memory usage in bytes.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar mem, _ = arrays.memory(a)\nfmt.Println(mem) \n</code></pre>"},{"location":"stdlib/arrays/#tojsonarray","title":"<code>tojson(array)</code>","text":"<p>Converts an array to a JSON string.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(string, error)</code>: The JSON string representation of the array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar json, _ = arrays.tojson(a)\nfmt.Println(json) // Output: [1,2,3]\n</code></pre>"},{"location":"stdlib/arrays/#tostringarray","title":"<code>tostring(array)</code>","text":"<p>Converts an array to a string representation.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(string, error)</code>: The string representation of the array.</p> <p>Example:</p> <pre><code>import fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar s, _ = arrays.tostring(a)\nfmt.Println(s) // Output: [1, 2, 3]\n</code></pre>"},{"location":"stdlib/assert/","title":"<code>assert</code> Module","text":"<p>The <code>assert</code> module provides functions for writing assertions, which are useful for testing.</p>"},{"location":"stdlib/assert/#functions","title":"Functions","text":""},{"location":"stdlib/assert/#assertcondition-message","title":"<code>Assert(condition, message?)</code>","text":"<p>Asserts that a condition is true. If the condition is false, the program will panic.</p> <p>Parameters: - <code>condition</code>: The condition to check. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example:</p> <pre><code>import assert\n\nassert.Assert(1 == 1, \"1 should be equal to 1\")\n// This will not panic\n\nassert.Assert(1 == 2, \"1 should not be equal to 2\")\n// This will panic\n</code></pre>"},{"location":"stdlib/assert/#asserteqactual-expected-message","title":"<code>AssertEq(actual, expected, message?)</code>","text":"<p>Asserts that two values are equal. If they are not, the program will panic.</p> <p>Parameters: - <code>actual</code>: The actual value. - <code>expected</code>: The expected value. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example:</p> <pre><code>import assert\n\nassert.AssertEq(42, 42, \"42 should be equal to 42\")\n// This will not panic\n\nassert.AssertEq(42, 43, \"42 should not be equal to 43\")\n// This will panic\n</code></pre>"},{"location":"stdlib/assert/#assertneactual-expected-message","title":"<code>AssertNe(actual, expected, message?)</code>","text":"<p>Asserts that two values are not equal. If they are, the program will panic.</p> <p>Parameters: - <code>actual</code>: The actual value. - <code>expected</code>: The expected value. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example:</p> <pre><code>import assert\n\nassert.AssertNe(42, 43, \"42 should not be equal to 43\")\n// This will not panic\n\nassert.AssertNe(42, 42, \"42 should be equal to 42\")\n// This will panic\n</code></pre>"},{"location":"stdlib/datetime/","title":"<code>datetime</code> Module","text":"<p>The <code>datetime</code> module provides a comprehensive set of functions for date and time operations, including timezone support, timers, and cron-like scheduling.</p>"},{"location":"stdlib/datetime/#functions","title":"Functions","text":""},{"location":"stdlib/datetime/#now","title":"<code>Now()</code>","text":"<p>Returns the current Unix timestamp.</p> <p>Returns: - <code>(integer, error)</code>: The current Unix timestamp.</p> <p>Example:</p> <pre><code>import fmt\nimport datetime\n\nvar now, _ = datetime.Now()\nfmt.Println(now)\n</code></pre>"},{"location":"stdlib/datetime/#formattimestamp-format","title":"<code>Format(timestamp, format)</code>","text":"<p>Formats a Unix timestamp into a string based on a layout.</p> <p>Parameters: - <code>timestamp</code>: An integer representing the Unix timestamp. - <code>format</code>: A string representing the layout. Supports \"RFC3339\", \"Kitchen\", \"Stamp\", or custom Go format strings.</p> <p>Returns: - <code>(string, error)</code>: The formatted time string.</p> <p>Example:</p> <pre><code>import fmt\nimport datetime\n\nvar now, _ = datetime.Now()\nvar formatted, _ = datetime.Format(now, \"RFC3339\")\nfmt.Println(formatted)\n</code></pre>"},{"location":"stdlib/datetime/#sleepseconds","title":"<code>Sleep(seconds)</code>","text":"<p>Pauses the execution for a given number of seconds.</p> <p>Parameters: - <code>seconds</code>: An integer or float representing the number of seconds to sleep.</p> <p>Example:</p> <pre><code>import fmt\nimport datetime\n\nfmt.Println(\"Sleeping for 2 seconds...\")\ndatetime.Sleep(2)\nfmt.Println(\"Awake!\")\n</code></pre>"},{"location":"stdlib/datetime/#yeartimestamp","title":"<code>Year(timestamp)</code>","text":"<p>Returns the year of a given Unix timestamp.</p> <p>Parameters: - <code>timestamp</code>: An integer representing the Unix timestamp.</p> <p>Returns: - <code>(integer, error)</code>: The year.</p>"},{"location":"stdlib/datetime/#monthtimestamp","title":"<code>Month(timestamp)</code>","text":"<p>Returns the month of a given Unix timestamp.</p> <p>Parameters: - <code>timestamp</code>: An integer representing the Unix timestamp.</p> <p>Returns: - <code>(integer, error)</code>: The month (1-12).</p>"},{"location":"stdlib/datetime/#daytimestamp","title":"<code>Day(timestamp)</code>","text":"<p>Returns the day of the month of a given Unix timestamp.</p> <p>Parameters: - <code>timestamp</code>: An integer representing the Unix timestamp.</p> <p>Returns: - <code>(integer, error)</code>: The day of the month (1-31).</p>"},{"location":"stdlib/datetime/#converttztimestamp-fromtz-totz","title":"<code>ConvertTZ(timestamp, fromTZ, toTZ)</code>","text":"<p>Converts a timestamp from one timezone to another.</p> <p>Parameters: - <code>timestamp</code>: An integer representing the Unix timestamp. - <code>fromTZ</code>: The source timezone (e.g., \"UTC\"). - <code>toTZ</code>: The target timezone (e.g., \"America/New_York\").</p> <p>Returns: - <code>(integer, error)</code>: The converted Unix timestamp.</p>"},{"location":"stdlib/datetime/#nowintztimezone","title":"<code>NowInTZ(timezone)</code>","text":"<p>Returns the current time in a specific timezone.</p> <p>Parameters: - <code>timezone</code>: The timezone (e.g., \"America/New_York\").</p> <p>Returns: - <code>(integer, error)</code>: The current Unix timestamp in the specified timezone.</p>"},{"location":"stdlib/datetime/#localtimelocale","title":"<code>LocalTime(locale)</code>","text":"<p>Returns the current time for a given locale.</p> <p>Parameters: - <code>locale</code>: A two-letter country code (e.g., \"US\", \"GB\").</p> <p>Returns: - <code>(integer, error)</code>: The current Unix timestamp in the locale's timezone.</p>"},{"location":"stdlib/datetime/#getsystemtz","title":"<code>GetSystemTZ()</code>","text":"<p>Returns the system's timezone name.</p> <p>Returns: - <code>(string, error)</code>: The system timezone.</p>"},{"location":"stdlib/datetime/#gettzoffsettimezone","title":"<code>GetTZOffset(timezone)</code>","text":"<p>Returns the timezone offset in seconds from UTC.</p> <p>Parameters: - <code>timezone</code>: The timezone name.</p> <p>Returns: - <code>(integer, error)</code>: The offset in seconds.</p>"},{"location":"stdlib/datetime/#timers-and-tickers","title":"Timers and Tickers","text":""},{"location":"stdlib/datetime/#newtimerid-delay_seconds","title":"<code>NewTimer(id, delay_seconds)</code>","text":"<p>Creates a new timer that will fire after a delay.</p>"},{"location":"stdlib/datetime/#checktimerid","title":"<code>CheckTimer(id)</code>","text":"<p>Checks if a timer has fired.</p>"},{"location":"stdlib/datetime/#stoptimerid","title":"<code>StopTimer(id)</code>","text":"<p>Stops a timer.</p>"},{"location":"stdlib/datetime/#newtickerid-interval_seconds","title":"<code>NewTicker(id, interval_seconds)</code>","text":"<p>Creates a new ticker that fires at regular intervals.</p>"},{"location":"stdlib/datetime/#stoptickerid","title":"<code>StopTicker(id)</code>","text":"<p>Stops a ticker.</p>"},{"location":"stdlib/datetime/#cron-scheduling","title":"Cron Scheduling","text":""},{"location":"stdlib/datetime/#isvalidcronexpression","title":"<code>IsValidCron(expression)</code>","text":"<p>Validates a cron expression.</p>"},{"location":"stdlib/datetime/#nextcronexecutionexpression-timestamp","title":"<code>NextCronExecution(expression, timestamp)</code>","text":"<p>Calculates the next execution time of a cron expression.</p>"},{"location":"stdlib/datetime/#parsecronexpression","title":"<code>ParseCron(expression)</code>","text":"<p>Parses a cron expression.</p>"},{"location":"stdlib/datetime/#schedulecronid-expression","title":"<code>ScheduleCron(id, expression)</code>","text":"<p>Schedules a cron job.</p>"},{"location":"stdlib/datetime/#stopcronid","title":"<code>StopCron(id)</code>","text":"<p>Stops a scheduled cron job.</p>"},{"location":"stdlib/datetime/#listcronjobs","title":"<code>ListCronJobs()</code>","text":"<p>Lists all active cron jobs.</p>"},{"location":"stdlib/datetime/#everyminute-hourly-daily-weekly-monthly","title":"<code>EveryMinute()</code>, <code>Hourly()</code>, <code>Daily()</code>, <code>Weekly()</code>, <code>Monthly()</code>","text":"<p>Returns common cron expressions.</p>"},{"location":"stdlib/errors/","title":"<code>errors</code> Module","text":"<p>The <code>errors</code> module provides functions for creating error objects.</p>"},{"location":"stdlib/errors/#functions","title":"Functions","text":""},{"location":"stdlib/errors/#newmessage","title":"<code>New(message)</code>","text":"<p>Creates a new error with a given message.</p> <p>Parameters: - <code>message</code>: The error message.</p> <p>Returns: - <code>(error, None)</code>: A new error object.</p> <p>Example:</p> <pre><code>import fmt\nimport errors\n\nvar err, _ = errors.New(\"something went wrong\")\nfmt.Println(err)\n</code></pre>"},{"location":"stdlib/errors/#errorfformat-args","title":"<code>Errorf(format, args...)</code>","text":"<p>Creates a new error with a formatted error message.</p> <p>Parameters: - <code>format</code>: A string that contains format specifiers. - <code>args...</code>: The arguments to be formatted.</p> <p>Returns: - <code>(error, None)</code>: A new error object.</p> <p>Example:</p> <pre><code>import fmt\nimport errors\n\nfunction divide(a, b) {\n    if b == 0 {\n        return None, errors.Errorf(\"division by zero: %d / %d\", a, b)\n    }\n    return a / b, None\n}\n\nvar result, err = divide(10, 0)\nif err != None {\n    fmt.Println(err)\n}\n</code></pre>"},{"location":"stdlib/file/","title":"<code>file</code> Module","text":"<p>The <code>file</code> module provides functions for interacting with the file system.</p>"},{"location":"stdlib/file/#functions","title":"Functions","text":""},{"location":"stdlib/file/#readfilename","title":"<code>Read(filename)</code>","text":"<p>Reads the entire content of a file.</p> <p>Parameters: - <code>filename</code>: The name of the file to read.</p> <p>Returns: - <code>(string, error)</code>: The content of the file.</p> <p>Example:</p> <pre><code>import fmt\nimport file\n\nvar content, err = file.Read(\"test.txt\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(content)\n}\n</code></pre>"},{"location":"stdlib/file/#writefilename-content","title":"<code>Write(filename, content)</code>","text":"<p>Writes content to a file. If the file does not exist, it will be created. If it exists, its contents will be overwritten.</p> <p>Parameters: - <code>filename</code>: The name of the file to write to. - <code>content</code>: The content to write.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example:</p> <pre><code>import file\n\nfile.Write(\"test.txt\", \"Hello, Harneet!\")\n</code></pre>"},{"location":"stdlib/file/#appendfilename-content","title":"<code>Append(filename, content)</code>","text":"<p>Appends content to a file. If the file does not exist, it will be created.</p> <p>Parameters: - <code>filename</code>: The name of the file to append to. - <code>content</code>: The content to append.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example:</p> <pre><code>import file\n\nfile.Append(\"test.txt\", \"\\nAnother line.\")\n</code></pre>"},{"location":"stdlib/file/#copysrc-dest","title":"<code>Copy(src, dest)</code>","text":"<p>Copies a file from a source path to a destination path.</p> <p>Parameters: - <code>src</code>: The source file path. - <code>dest</code>: The destination file path.</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/file/#sizefilename","title":"<code>Size(filename)</code>","text":"<p>Returns the size of a file in bytes.</p> <p>Parameters: - <code>filename</code>: The name of the file.</p> <p>Returns: - <code>(integer, error)</code>: The size of the file in bytes.</p> <p>```</p>"},{"location":"stdlib/fmt/","title":"<code>fmt</code> Module","text":"<p>The <code>fmt</code> module provides functions for formatting and printing output to the console.</p>"},{"location":"stdlib/fmt/#functions","title":"Functions","text":""},{"location":"stdlib/fmt/#printlnargs","title":"<code>Println(args...)</code>","text":"<p>Prints the given arguments to the console, followed by a newline character.</p> <p>Parameters: - <code>args...</code>: A variable number of arguments of any type.</p> <p>Returns: - <code>(None, error)</code>: This function does not return a value, but it follows the standard error handling pattern.</p> <p>Example:</p> <pre><code>import fmt\n\nfmt.Println(\"Hello, World!\")\nvar x = 42\nfmt.Println(\"The value of x is:\", x)\n</code></pre>"},{"location":"stdlib/fmt/#printargs","title":"<code>Print(args...)</code>","text":"<p>Prints the given arguments to the console without a newline character at the end.</p> <p>Parameters: - <code>args...</code>: A variable number of arguments of any type.</p> <p>Returns: - <code>(None, error)</code>: This function does not return a value, but it follows the standard error handling pattern.</p> <p>Example:</p> <pre><code>import fmt\n\nfmt.Print(\"Hello, \")\nfmt.Print(\"World!\")\n// Output: Hello, World!\n</code></pre>"},{"location":"stdlib/fmt/#printfformat-args","title":"<code>Printf(format, args...)</code>","text":"<p>Prints formatted output to the console. It uses a format string and a variable number of arguments.</p> <p>Parameters: - <code>format</code>: A string that contains format specifiers. - <code>args...</code>: The arguments to be formatted.</p> <p>Returns: - <code>(None, error)</code>: This function does not return a value, but it follows the standard error handling pattern.</p> <p>Format Specifiers: - <code>%v</code>: The default format for the value. - <code>%s</code>: A string. - <code>%d</code>: A decimal integer. - <code>%f</code>: A floating-point number.</p> <p>Example:</p> <pre><code>import fmt\n\nvar name = \"Alice\"\nvar age = 30\nfmt.Printf(\"Name: %s, Age: %d\", name, age)\n</code></pre>"},{"location":"stdlib/fmt/#errorfformat-args","title":"<code>Errorf(format, args...)</code>","text":"<p>Creates a new error with a formatted error message.</p> <p>Parameters: - <code>format</code>: A string that contains format specifiers. - <code>args...</code>: The arguments to be formatted.</p> <p>Returns: - <code>(error, None)</code>: A new error object.</p> <p>Example:</p> <pre><code>import fmt\nimport errors\n\nfunction divide(a, b) {\n    if b == 0 {\n        return None, errors.Errorf(\"division by zero: %d / %d\", a, b)\n    }\n    return a / b, None\n}\n\nvar result, err = divide(10, 0)\nif err != None {\n    fmt.Println(err)\n}\n</code></pre>"},{"location":"stdlib/json/","title":"<code>json</code> Module","text":"<p>The <code>json</code> module provides functions for working with JSON data.</p>"},{"location":"stdlib/json/#functions","title":"Functions","text":""},{"location":"stdlib/json/#marshalvalue","title":"<code>Marshal(value)</code>","text":"<p>Converts a Harneet value to a JSON string.</p> <p>Parameters: - <code>value</code>: The value to convert.</p> <p>Returns: - <code>(string, error)</code>: The JSON string representation of the value.</p> <p>Example:</p> <pre><code>import fmt\nimport json\n\nvar data = [\"apple\", \"banana\", \"cherry\"]\nvar jsonString, err = json.Marshal(data)\nif err != None {\n    fmt.Println(\"Marshal error:\", err)\n} else {\n    fmt.Println(jsonString) // Output: [\"apple\",\"banana\",\"cherry\"]\n}\n</code></pre>"},{"location":"stdlib/json/#unmarshaljson_string","title":"<code>Unmarshal(json_string)</code>","text":"<p>Parses a JSON string into a Harneet value.</p> <p>Parameters: - <code>json_string</code>: The JSON string to parse.</p> <p>Returns: - <code>(any, error)</code>: The parsed Harneet value.</p> <p>Example:</p> <pre><code>import fmt\nimport json\n\nvar jsonString = \"[\\\"apple\\\",\\\"banana\\\",\\\"cherry\\\"]\"\nvar parsed, parseErr = json.Unmarshal(jsonString)\nif parseErr != None {\n    fmt.Println(\"Parse error:\", parseErr)\n} else {\n    fmt.Println(parsed) // Output: [apple, banana, cherry]\n}\n</code></pre>"},{"location":"stdlib/json/#validjson_string","title":"<code>Valid(json_string)</code>","text":"<p>Checks if a string is a valid JSON.</p> <p>Parameters: - <code>json_string</code>: The string to check.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the string is valid JSON, <code>false</code> otherwise.</p>"},{"location":"stdlib/json/#indentjson-prefix-indent","title":"<code>Indent(json, prefix, indent)</code>","text":"<p>Formats a JSON string with indentation.</p> <p>Parameters: - <code>json</code>: The JSON string to format. - <code>prefix</code>: The prefix for each line. - <code>indent</code>: The indentation string.</p> <p>Returns: - <code>(string, error)</code>: The indented JSON string.</p> <p>```</p>"},{"location":"stdlib/log/","title":"<code>log</code> Module","text":"<p>The <code>log</code> module provides a simple logging interface.</p>"},{"location":"stdlib/log/#functions","title":"Functions","text":""},{"location":"stdlib/log/#infomessage","title":"<code>Info(message)</code>","text":"<p>Logs a message at the INFO level.</p> <p>Parameters: - <code>message</code>: The message to log.</p> <p>Example:</p> <pre><code>import log\n\nlog.Info(\"This is an informational message.\")\n</code></pre>"},{"location":"stdlib/log/#warnmessage","title":"<code>Warn(message)</code>","text":"<p>Logs a message at the WARN level.</p> <p>Parameters: - <code>message</code>: The message to log.</p> <p>Example:</p> <pre><code>import log\n\nlog.Warn(\"This is a warning message.\")\n</code></pre>"},{"location":"stdlib/log/#errormessage","title":"<code>Error(message)</code>","text":"<p>Logs a message at the ERROR level.</p> <p>Parameters: - <code>message</code>: The message to log.</p> <p>Example:</p> <pre><code>import log\n\nlog.Error(\"This is an error message.\")\n</code></pre>"},{"location":"stdlib/log/#debugmessage","title":"<code>Debug(message)</code>","text":"<p>Logs a message at the DEBUG level.</p> <p>Parameters: - <code>message</code>: The message to log.</p> <p>Example:</p> <pre><code>import log\n\nlog.Debug(\"This is a debug message.\")\n</code></pre>"},{"location":"stdlib/math/","title":"<code>math</code> Module","text":"<p>The <code>math</code> module provides basic mathematical operations.</p>"},{"location":"stdlib/math/#functions","title":"Functions","text":""},{"location":"stdlib/math/#absnumber","title":"<code>Abs(number)</code>","text":"<p>Returns the absolute value of a number.</p> <p>Parameters: - <code>number</code>: An integer or a float.</p> <p>Returns: - <code>(number, error)</code>: The absolute value of the number, or an error if the argument is not a number.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Abs(-42)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 42\n}\n</code></pre>"},{"location":"stdlib/math/#maxa-b","title":"<code>Max(a, b)</code>","text":"<p>Returns the maximum of two numbers.</p> <p>Parameters: - <code>a</code>: An integer or a float. - <code>b</code>: An integer or a float.</p> <p>Returns: - <code>(number, error)</code>: The larger of the two numbers, or an error if the arguments are not numbers.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Max(10, 20)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 20\n}\n</code></pre>"},{"location":"stdlib/math/#mina-b","title":"<code>Min(a, b)</code>","text":"<p>Returns the minimum of two numbers.</p> <p>Parameters: - <code>a</code>: An integer or a float. - <code>b</code>: An integer or a float.</p> <p>Returns: - <code>(number, error)</code>: The smaller of the two numbers, or an error if the arguments are not numbers.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Min(10, 20)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 10\n}\n</code></pre>"},{"location":"stdlib/math/#powbase-exponent","title":"<code>Pow(base, exponent)</code>","text":"<p>Returns the base to the power of the exponent.</p> <p>Parameters: - <code>base</code>: An integer or a float. - <code>exponent</code>: An integer or a float.</p> <p>Returns: - <code>(number, error)</code>: The result of the power operation, or an error if the arguments are not numbers.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Pow(2, 3)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 8\n}\n</code></pre>"},{"location":"stdlib/os/","title":"<code>os</code> Module","text":"<p>The <code>os</code> module provides a way to interact with the operating system.</p>"},{"location":"stdlib/os/#functions","title":"Functions","text":""},{"location":"stdlib/os/#getenvname","title":"<code>Getenv(name)</code>","text":"<p>Gets the value of an environment variable.</p> <p>Parameters: - <code>name</code>: The name of the environment variable.</p> <p>Returns: - <code>(string, error)</code>: The value of the environment variable, or an empty string if it's not set.</p> <p>Example:</p> <pre><code>import fmt\nimport os\n\nvar home, _ = os.Getenv(\"HOME\")\nfmt.Println(\"HOME directory:\", home)\n</code></pre>"},{"location":"stdlib/os/#setenvname-value","title":"<code>Setenv(name, value)</code>","text":"<p>Sets the value of an environment variable.</p> <p>Parameters: - <code>name</code>: The name of the environment variable. - <code>value</code>: The value to set.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example:</p> <pre><code>import os\n\nos.Setenv(\"MY_VAR\", \"my_value\")\n</code></pre>"},{"location":"stdlib/os/#type","title":"<code>Type()</code>","text":"<p>Returns the operating system type.</p> <p>Returns: - <code>(string, error)</code>: The OS type (e.g., \"darwin\", \"linux\", \"windows\").</p> <p>Example:</p> <pre><code>import fmt\nimport os\n\nvar osType, _ = os.Type()\nfmt.Println(\"OS Type:\", osType)\n</code></pre>"},{"location":"stdlib/os/#version","title":"<code>Version()</code>","text":"<p>Returns the operating system version.</p> <p>Returns: - <code>(string, error)</code>: The OS version.</p>"},{"location":"stdlib/os/#arch","title":"<code>Arch()</code>","text":"<p>Returns the system architecture.</p> <p>Returns: - <code>(string, error)</code>: The architecture (e.g., \"amd64\", \"arm64\").</p>"},{"location":"stdlib/os/#getwd","title":"<code>Getwd()</code>","text":"<p>Returns the current working directory.</p> <p>Returns: - <code>(string, error)</code>: The current working directory path.</p>"},{"location":"stdlib/os/#chdirpath","title":"<code>Chdir(path)</code>","text":"<p>Changes the current working directory.</p> <p>Parameters: - <code>path</code>: The path to the new directory.</p>"},{"location":"stdlib/os/#mkdirpath","title":"<code>Mkdir(path)</code>","text":"<p>Creates a new directory.</p> <p>Parameters: - <code>path</code>: The path of the directory to create.</p>"},{"location":"stdlib/os/#removepath","title":"<code>Remove(path)</code>","text":"<p>Removes a file or directory.</p> <p>Parameters: - <code>path</code>: The path of the file or directory to remove.</p>"},{"location":"stdlib/os/#existspath","title":"<code>Exists(path)</code>","text":"<p>Checks if a file or directory exists.</p> <p>Parameters: - <code>path</code>: The path to check.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the path exists, <code>false</code> otherwise.</p>"},{"location":"stdlib/os/#listdevices","title":"<code>ListDevices()</code>","text":"<p>Lists the system devices.</p>"},{"location":"stdlib/os/#getdeviceinfodevice","title":"<code>GetDeviceInfo(device)</code>","text":"<p>Gets information about a specific device.</p>"},{"location":"stdlib/path/","title":"<code>path</code> Module","text":"<p>The <code>path</code> module provides functions for working with file paths.</p>"},{"location":"stdlib/path/#functions","title":"Functions","text":""},{"location":"stdlib/path/#joinparts","title":"<code>Join(parts...)</code>","text":"<p>Joins any number of path elements into a single path.</p> <p>Parameters: - <code>parts...</code>: The path elements to join.</p> <p>Returns: - <code>(string, error)</code>: The joined path.</p> <p>Example:</p> <pre><code>import fmt\nimport path\n\nvar p, _ = path.Join(\"/home\", \"user\", \"file.txt\")\nfmt.Println(p) // Output: /home/user/file.txt\n</code></pre>"},{"location":"stdlib/path/#dirpath","title":"<code>Dir(path)</code>","text":"<p>Returns the directory portion of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The directory portion.</p> <p>Example:</p> <pre><code>import fmt\nimport path\n\nvar dir, _ = path.Dir(\"/home/user/file.txt\")\nfmt.Println(dir) // Output: /home/user\n</code></pre>"},{"location":"stdlib/path/#basepath","title":"<code>Base(path)</code>","text":"<p>Returns the last element of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The last element.</p> <p>Example:</p> <pre><code>import fmt\nimport path\n\nvar base, _ = path.Base(\"/home/user/file.txt\")\nfmt.Println(base) // Output: file.txt\n</code></pre>"},{"location":"stdlib/path/#extpath","title":"<code>Ext(path)</code>","text":"<p>Returns the file extension of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The file extension.</p> <p>Example:</p> <pre><code>import fmt\nimport path\n\nvar ext, _ = path.Ext(\"/home/user/file.txt\")\nfmt.Println(ext) // Output: .txt\n</code></pre>"},{"location":"stdlib/path/#abspath","title":"<code>Abs(path)</code>","text":"<p>Returns an absolute representation of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The absolute path.</p> <p>Example:</p> <pre><code>import fmt\nimport path\n\nvar abs, _ = path.Abs(\"file.txt\")\nfmt.Println(abs)\n</code></pre>"},{"location":"stdlib/strings/","title":"<code>strings</code> Module","text":"<p>The <code>strings</code> module provides functions for string manipulation.</p>"},{"location":"stdlib/strings/#functions","title":"Functions","text":""},{"location":"stdlib/strings/#lenstring","title":"<code>Len(string)</code>","text":"<p>Returns the length of a string.</p> <p>Parameters: - <code>string</code>: A string.</p> <p>Returns: - <code>(integer, error)</code>: The length of the string, or an error if the argument is not a string.</p> <p>Example:</p> <pre><code>import fmt\nimport strings\n\nvar length, err = strings.Len(\"hello\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Length:\", length) // Output: Length: 5\n}\n</code></pre>"},{"location":"stdlib/strings/#upperstring","title":"<code>Upper(string)</code>","text":"<p>Converts a string to uppercase.</p> <p>Parameters: - <code>string</code>: A string.</p> <p>Returns: - <code>(string, error)</code>: The uppercase version of the string, or an error if the argument is not a string.</p> <p>Example:</p> <pre><code>import fmt\nimport strings\n\nvar upper, err = strings.Upper(\"hello\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Uppercase:\", upper) // Output: Uppercase: HELLO\n}\n</code></pre>"},{"location":"stdlib/strings/#lowerstring","title":"<code>Lower(string)</code>","text":"<p>Converts a string to lowercase.</p> <p>Parameters: - <code>string</code>: A string.</p> <p>Returns: - <code>(string, error)</code>: The lowercase version of the string, or an error if the argument is not a string.</p> <p>Example:</p> <pre><code>import fmt\nimport strings\n\nvar lower, err = strings.Lower(\"HELLO\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Lowercase:\", lower) // Output: Lowercase: hello\n}\n</code></pre>"},{"location":"stdlib/strings/#containsstring-substring","title":"<code>Contains(string, substring)</code>","text":"<p>Checks if a string contains a substring.</p> <p>Parameters: - <code>string</code>: The string to search in. - <code>substring</code>: The substring to search for.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the substring is found, <code>false</code> otherwise. Returns an error if the arguments are not strings.</p> <p>Example:</p> <pre><code>import fmt\nimport strings\n\nvar found, err = strings.Contains(\"hello world\", \"world\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Found:\", found) // Output: Found: true\n}\n</code></pre>"},{"location":"stdlib/strings/#replacestring-old-new","title":"<code>Replace(string, old, new)</code>","text":"<p>Replaces all occurrences of a substring with a new string.</p> <p>Parameters: - <code>string</code>: The original string. - <code>old</code>: The substring to be replaced. - <code>new</code>: The new string to replace with.</p> <p>Returns: - <code>(string, error)</code>: A new string with all occurrences of <code>old</code> replaced by <code>new</code>. Returns an error if the arguments are not strings.</p> <p>Example:</p> <pre><code>import fmt\nimport strings\n\nvar replaced, err = strings.Replace(\"hello world\", \"world\", \"Harneet\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Replaced:\", replaced) // Output: Replaced: hello Harneet\n}\n</code></pre>"},{"location":"stdlib/strings/#splitstring-separator","title":"<code>Split(string, separator)</code>","text":"<p>Splits a string into an array of substrings.</p> <p>Parameters: - <code>string</code>: The string to be split. - <code>separator</code>: The separator to split by.</p> <p>Returns: - <code>(array, error)</code>: An array of strings. Returns an error if the arguments are not strings.</p> <p>Example:</p> <pre><code>import fmt\nimport strings\n\nvar parts, err = strings.Split(\"a,b,c\", \",\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Parts:\", parts) // Output: Parts: [a, b, c]\n}\n</code></pre>"},{"location":"stdlib/strings/#tointstring","title":"<code>ToInt(string)</code>","text":"<p>Parses a string to an integer.</p> <p>Parameters: - <code>string</code>: The string to be parsed.</p> <p>Returns: - <code>(integer, error)</code>: The integer value, or an error if the string cannot be parsed as an integer.</p> <p>Example:</p> <pre><code>import fmt\nimport strings\n\nvar number, err = strings.ToInt(\"42\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Number:\", number) // Output: Number: 42\n}\n\nvar invalid, err2 = strings.ToInt(\"hello\")\nif err2 != None {\n    fmt.Println(\"Error:\", err2) // Output: Error: cannot convert 'hello' to int\n}\n</code></pre>"}]}